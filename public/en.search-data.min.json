[{"id":0,"href":"/interview/android/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","title":"事件处理","parent":"Android","content":"  Q:如何捕获activity中的所有点击事件? Q:说说view中的事件分发? Q:如果我只想有view的拖拽事件，而不想要view的点击事件，让你重写这个view的拖拽怎么设计? Q:里面的view在onTouchEvent中消费，然后拖动手指，直到手指从其他他viewgroup上挪开手指 Q:view的onTouch和onTouchEvent事件的区别？ Q:view的onClick事件在什么时候触发的，和onTouch有什么区别? Q:事件是先到window的还是先到decorview的,为什么这样设计? Q:一个点击事件是如何从屏幕传递到view的? Q:MotionEvent是什么?有什么用? Q:ACTION_CANCEL是如何触发的? Q:几个监听Lisner动作回调的优先级是如何? Q:滑动冲突如何解决? Q:Activity的分发方法中调用了onUserInteraction()方法，你能说说这个方法有什么作用吗？ Q:ViewGroup是如何将多个手指产生的事件准确分发给不同的子view的？   Q:如何捕获activity中的所有点击事件?     事件分发方案。通过重写Activity的dispatchTouchEvent方法，对页面上的点击事件进行拦截。但是拦截不到Dialog中的点击事件，因为事件分发由DecorView开始发起，但是Dialog所处的DecorView和Activity的DecorView不是同一个，所以无法在Activitiy的dispatchTouchEvent方法进行拦截Dialog中的点击事件。 hook替换OnClickListener方案。这个方案主要是通过替换View中的mOnClickListener为我们自己的OnClickListener，然后进行点击事件的拦截处理。但是这个方案需要获取替换的那个View才行，所以新增的View和Dialog都需要单独处理才行。新增的View需要进行当前页面的View树进行监听，Dialog必须对Dialog中的View再进行一次hook。 AspectJ切面编程方案。这个方案是在编译期将代码插入到目标方法中，所以只要找到切点——也就是View中的onClick方法即可。可以完美解决我们的问题，并且不需要用户另外操作。 无障碍服务方案。这个方案是通过Android中的无障碍服务，对APP中的所有点击事件进行拦截，对应的事件就是AccessibilityEvent.TYPE_VIEW_CLICKED。该方案也能完美解决我们的问题，但是有个很大的缺点，就是需要用户单独去设置页面开启该辅助服务才行。  Q:说说view中的事件分发?    ACTION_DOWN情况下:dispatchTouchEvent-\u0026gt;onIntercepterTouchEvenet-\u0026gt;onTouchEvent\nQ:如果我只想有view的拖拽事件，而不想要view的点击事件，让你重写这个view的拖拽怎么设计?    onTouchEvent中return true\nQ:里面的view在onTouchEvent中消费，然后拖动手指，直到手指从其他他viewgroup上挪开手指    一旦事件点击序列传到了view中,这个序列中的所有操作都交给这个view去处理\nQ:view的onTouch和onTouchEvent事件的区别？    onTouch指setOnTouchListener的回调方法，它是优先于onTouchEvent事件的,如果onTouch方法返回true，是不会触发onTouchEvent事件的\nQ:view的onClick事件在什么时候触发的，和onTouch有什么区别?    在onTouchEvent中的ACTION_UP中触发的,onTouch是在dispatchTouchEvent中触发的\nQ:事件是先到window的还是先到decorview的,为什么这样设计?    这样设计是为了解耦，Activity只持有phonewindow,ViewRootImpl只持有decorview,phonewindow可以把事件分发到decorview\nQ:一个点击事件是如何从屏幕传递到view的?    Q:MotionEvent是什么?有什么用?    一个MotionEvent对象内部使用一个数组来维护所有触控点的信息 UP/DOWN类型的事件包含了触控点索引，可以根据该索引做出对应的操作 触控点的索引是变化的，不能作为跟踪的依据，而必须依据触控点id\n ACTION_DOWN: 表示手指按下屏幕 ACTION_MOVE: 手指在屏幕上滑动时，会产生一系列的MOVE事件 ACTION_UP: 手指抬起，离开屏幕、 ACTION_CANCEL：当出现异常情况事件序列被中断，会产生该类型事件 ACTION_POINTER_DOWN: 当已经有一个手指按下的情况下，另一个手指按下会产生该事件 ACTION_POINTER_UP: 多个手指同时按下的情况下，抬起其中一个手指会产生该事件  Q:ACTION_CANCEL是如何触发的?    ViewGroup在onInterceptTouchEvent中对ACTION_MOVE或者ACTION_UP进行了拦截,子View的dispatchTouchEvent和onTouchEvent就接收到的是ACTION_CACEL\nQ:几个监听Lisner动作回调的优先级是如何?    if (mOnTouchListener!=null \u0026amp;\u0026amp; mTouchListener.onTouch(event)){ return true; }else{ if (单击事件){ mOnClickListener.onClick(view); }else if(长按事件){ mOnLongClickListener.onLongClick(view); } } Q:滑动冲突如何解决?     外部拦截法中，重点在于是否拦截事件，那么重心就放在了 onInterceptTouchEvent 方法中 内部拦截法中,首先是设置外部viewGroup拦截除了down事件以外的所有事件,接下来需要重写内部view的dispatchTouchEvent方法  Q:Activity的分发方法中调用了onUserInteraction()方法，你能说说这个方法有什么作用吗？    这个方法在Activity接收到down的时候会被调用，本身是个空方法，需要开发者自己去重写\nQ:ViewGroup是如何将多个手指产生的事件准确分发给不同的子view的？     每个MotionEvent中都包含了当前屏幕所有触控点的信息，他的内部用了一个数组来存储不同的触控id所对应的坐标数值。 当一个子view消费了down事件之后，ViewGroup会为该view创建一个TouchTarget，这个TouchTarget就包含了该view的实例与触控id。这里的触控id可以是多个，也就是一个view可接受多个触控点的事件序列。 当一个MotionEvent到来之时，ViewGroup会将其中的触控点信息拆开，再分别发送给感兴趣的子view。从而达到精准发送触控点信息的目的。  "},{"id":1,"href":"/interview/android/activity/","title":"Activity","parent":"Android","content":"  Q:简述下Activity相关生命周期 Q:onStart调用后,用户就真正可以看见activity了吗? Q:Activity生命周期中,任务栈是怎么变化的 Q:onSaveInstance和onRestoreInstance的调用时机,系统会默认干些什么 Q:为什么不建议在onPause中处理耗时操作 Q:什么情况下activity会调用onPause Q:activity在onDestroy中做了什么？ Q:哪些是在activity清单文件配置中的必要元素,哪些是发布后不建议修改元素,为什么 Q:intent-filter过滤器是什么，有什么作用,其中各标签代表什么含义 Q:intent-filter是如何响应,然后启动activity的 Q:activity中的权限控制是怎么样的,详细解释下 Q:用户离开activity时,activity一定会被销毁吗？ Q:activity实例的销毁时机,系统会直接销毁activity吗 Q:setResult调用时机 Q:setResult可能会出现什么问题?如何解决？ Q:在有setResult时,activity的生命周期是什么样的? Q:activityA启动activityB时的生命周期?为什么要这样设计? Q:activity状态改变 Q:activity还有其他什么生命周期的函数,分别调用时机是什么时刻 Q:activity启动方式 Q:taskAffinity是做什么用的?有什么具体的应用场景? Q:如果一个A Activity（standard）启动B Activity（singleInstance），这个时候用户点击了手机最近访问列表，然后在再点击该App所在的界面（卡片），然后这个时候点击返回键,会发生什么?为什么? Q:任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？ Q:有多少种操作activity任务堆栈的方式?操作的结果是什么？ Q:可以从后台启动activity吗?怎么做?   Q:在不同的生命周期内调用finish的生命周期是怎么样的? Q:finish调用后会立刻调用onStop、onDestroy吗？不会的话,为什么? Q:如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？ Q:启动一个Dialog,activity生命周期是如何变化的?为什么? Q:onSaveInstance是如何实现保持应用状态的?如果在里面传递大量数据会发生什么? Q:onResume执行了就可以认为界面对用户可见了?这种理解对吗? Q:一个activity从创建到用户可见,经历了什么操作,涉及到了哪些生命周期? Q:什么情况下startActivity需要设置Flag=NEW_TASK?为什么?不设置的话会发生什么? Q:activity从启动到显示,都经历了什么? Q:activity在屏幕旋转后如何保持下载不中断? Q:startActivities是干什么用的?activity栈是如何变化的? Q:Activity启动模式与FLAG结合? Q:Flag使用具体使用? Q:子线程可以startActivity吗?会有什么问题?   Q:简述下Activity相关生命周期    onCreate-\u0026gt;onRestart-\u0026gt;onStart-\u0026gt;onRestoreInstance-\u0026gt;onResume-\u0026gt;onPause-\u0026gt;onStop-\u0026gt;onRestrt-\u0026gt;onDestroy onSaveInstance onRestoreInstance\n  onCreate:Activity生命周期的第一个方法，也是我们在android开发中接触的最多的生命周期方法。它本身的作用是进行Activity的一些初始化工作，比如使用setContentView加载布局，对一些控件和变量进行初始化等，此时activity还在后台,不可见\n  onStart:对用户可见(这个可见指的是进程的可见),在此时包含activity进入前台与用户互动之前的最后准备工作\n  onResume:系统会在 Activity 开始与用户互动之前调用此回调。此时，该 Activity 位于 Activity 堆栈的顶部，并会捕获所有用户输入\n  onPause:Activity 失去焦点并进入“已暂停”状态\n  onStop:当 Activity 对用户不再可见时，系统会调用 onStop()\n  onRestart:当处于“已停止”状态的 Activity 即将重启时，系统就会调用此回调。onRestart() 会从 Activity 停止时的状态恢复 Activity。 此回调后面总是跟着 onStart()\n  onDestroy:系统会在销毁 Activity 之前调用此回调\n  Q:onStart调用后,用户就真正可以看见activity了吗?    不能,onStart的可见指的是进程优先级中的可见,用户肉眼的可见需要在onResume方法执行之后再调用Activity.makeVisible()方法，我们才能真正用肉眼看到我们的DecoreView\nQ:Activity生命周期中,任务栈是怎么变化的    新Activity在onCreate时就会被移到任务栈的栈顶\nQ:onSaveInstance和onRestoreInstance的调用时机,系统会默认干些什么      onSaveInstanceState:当用户显式关闭 Activity 时，或者在其他情况下调用 finish() 时，系统不会调用 onSaveInstanceState()。只有发生诸如配置变化等可能恢复activity的操作时,系统才会调用onSaveInstance,在onStop之前(在API28之后onSaveInstanceState()方法的执行放在了onStop()之后)默认保存view的一些瞬时信息\n  onRestoreInstance:在onStart之后调用,不用判断bundle是否为空,您应始终调用 onRestoreInstanceState() 的父类实现，以便默认实现可以恢复视图层次结构的状态。\n  Q:为什么不建议在onPause中处理耗时操作    因为系统在上一个activity的onPause执行结束后才会调用下一个activity的创建工作,在onPause中执行耗时操作会影响下一个actviity的启动\nQ:什么情况下activity会调用onPause     来自用户的终端操作,比如来电、用户导航到另一个 Activity，或设备屏幕关闭 有多个应用在多窗口模式下运行。无论何时，都只有一个应用（窗口）可以拥有焦点，因此系统会暂停所有其他应用 有新的半透明 Activity（例如对话框）处于开启状态。只要 Activity 仍然部分可见但并未处于焦点之中，它便会一直暂停  Q:activity在onDestroy中做了什么？    清理资源,\nQ:哪些是在activity清单文件配置中的必要元素,哪些是发布后不建议修改元素,为什么    清单文件中activity的唯一的必要属性是 android:name，该属性用于指定 Activity 的类名称\nQ:intent-filter过滤器是什么，有什么作用,其中各标签代表什么含义    Intent Filter（意图过滤器）其实就是用来匹配隐式Intent的，当一个意图对象被一个意图过滤器进行匹配测试时，只有三个方面会被参考到：动作、数据（URI以及数据类型）和类别\nQ:intent-filter是如何响应,然后启动activity的    PMS中的queryIntentActivities去判断启动哪个activity\nQ:activity中的权限控制是怎么样的,详细解释下    uses-permission标签声明访问activity所需要的权限 binder中的pid和uid进行权限控制\nQ:用户离开activity时,activity一定会被销毁吗？    不会,只有永久性离开时才会销毁activity\nQ:activity实例的销毁时机,系统会直接销毁activity吗     当用户按下返回按钮或您的 Activity 通过调用 finish() 方法发出销毁信号时 系统因系统限制（例如配置变更或内存压力）而销毁 Activity  Q:setResult调用时机    在finish之前调用,当按下back键时生命周期调用 ActivityB.finish()-\u0026gt;ActivityB.onBackPressed()-\u0026gt;ActivityA.onActivityResult()-\u0026gt;ActivityA.restart()\nQ:setResult可能会出现什么问题?如何解决？    会导致singleTask、singleInstance不起效,B设置为singleInstance,A以startActivity启动B,B会在新的task中,以startActivityForResult启动B,B不会在新的task中\nQ:在有setResult时,activity的生命周期是什么样的?     ActivityB 的onPause执行 ActivityA 的onActivityResult -\u0026gt; onRestart -\u0026gt; onResume ActivityB 的onStop执行  Q:activityA启动activityB时的生命周期?为什么要这样设计?     Activity A 的 onPause() 方法执行。 Activity B 的 onCreate()、onStart() 和 onResume() 方法依次执行（Activity B 现在具有用户焦点）。 然后，如果 Activity A 在屏幕上不再显示，其 onStop() 方法执行。  这样设计是为了用户的使用体验,当onPause执行后,当前activity就会进入后台进程,资源就优先分配给后来展示的前台进程\nQ:activity状态改变     配置改变,比如横竖屏切换:重建生命周期 多窗口:onPause-\u0026gt;onResume相互切换 Activity 或对话框显示在前台:当被覆盖的 Activity 的同一实例返回到前台时，系统会对该 Activity 调用 onRestart()、onStart() 和 onResume()。如果被覆盖的 Activity 的新实例进入后台，则系统不会调用 onRestart()，而只会调用 onStart() 和 onResume()。 用户点按“返回”按钮:Activity 将依次经历 onPause()、onStop() 和 onDestroy() 回调。活动不仅会被销毁，还会从返回堆栈中移除  Q:activity还有其他什么生命周期的函数,分别调用时机是什么时刻      onPostCreate方法发生在onRestoreInstanceState之后，onResume之前，他代表着界面数据已经完全恢复，就差显示出来与用户交互了。在onStart方法被调用时这些操作尚未完成。\n  onPostResume是在Resume方法被完全执行之后的回调。\n  onContentChange是在setContentView之后的回调。\n  Q:activity启动方式     standard:默认值。系统在启动该 Activity 的任务中创建 Activity 的新实例 singleTop:如果当前任务的顶部已存在 Activity 的实例，则系统会通过调用其 onNewIntent() 方法来将 intent 转送给该实例，而不是创建 Activity 的新实例,适合启动同类型的 Activity，例如接收通知启动的内容显示页面 singleTask:任务栈中只有一个activity实例,默认带有clearTop效果,适合作为程序入口 singleInstance:任务栈中有且只有一个activity实例,适合需要与程序分离开的页面，例如闹铃的响铃界面  Q:taskAffinity是做什么用的?有什么具体的应用场景?    官方翻译过来叫做任务亲和性,可以理解为activityTask任务栈的一个别名,常与singleTask或者allowTaskReparenting属性共同使用,默认为应用包名,比如A设置启动方式为singleTask,设置taskAffinity为\u0026quot;com.xxx.a\u0026quot;,则从A启动的B,任务栈也就变成了com.xxx.a\nQ:如果一个A Activity（standard）启动B Activity（singleInstance），这个时候用户点击了手机最近访问列表，然后在再点击该App所在的界面（卡片），然后这个时候点击返回键,会发生什么?为什么?    会返回桌面,因为从手机最近访问列表进入app所在卡片相当于以singleInstance方式启动了B activity,这是B所在的任务栈只有B一个activity\nQ:任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？    Q:有多少种操作activity任务堆栈的方式?操作的结果是什么？    如果用户离开任务较长时间，系统会清除任务中除根 Activity 以外的所有 Activity。当用户再次返回到该任务时，只有根 Activity 会恢复 可以使用一些 Activity 属性来修改此行为：\n alwaysRetainTaskState 如果在任务的根 Activity 中将该属性设为 \u0026ldquo;true\u0026rdquo;，则不会发生上述默认行为。即使经过很长一段时间后，任务仍会在其堆栈中保留所有 Activity。 clearTaskOnLaunch 如果在任务的根 Activity 中将该属性设为 \u0026ldquo;true\u0026rdquo;，那么只要用户离开任务再返回，堆栈就会被清除到只剩根 Activity。也就是说，它与 alwaysRetainTaskState 正好相反。用户始终会返回到任务的初始状态，即便只是短暂离开任务也是如此。 finishOnTaskLaunch 该属性与 clearTaskOnLaunch 类似，但它只会作用于单个 Activity 而非整个任务。它还可导致任何 Activity 消失，包括根 Activity。如果将该属性设为 \u0026ldquo;true\u0026rdquo;，则 Activity 仅在当前会话中归属于任务。如果用户离开任务再返回，则该任务将不再存在  Q:可以从后台启动activity吗?怎么做?    可以, 原生Android ROM Android 原生 ROM 都能正常地从后台启动 Activity 界面，无论是 Android 9(直接启动) 还是 10 版本(借助全屏通知)。 定制化ROM\n 检测后台弹出界面权限： 通过反射 AppOpsManager 相关方法检测对应 opCode 的权限； opCode = 10021(小米机型)； 其它机型可以尝试遍历得到 opCode； 通过moveTaskToFront将应用切到前台  Q:用户在调用finish时发生了什么?    通过该应用进程ActivityThread的Handler发消息到主线程的消息队列中，然后会回调onpause，onstop，ondestroy（）。然后这个Activity的其他生命周期不会再被调用了。还会销毁该Activity的界面。触摸事件到了该应用进程主线程消息队列后（假如从该Activity返回后去到的Activity也是在同一进程的），也不会分派给这个Activity了\nQ:在不同的生命周期内调用finish的生命周期是怎么样的?     在onCreate中：onCreate-\u0026gt;onDestroy 在onStart中：onCreate-\u0026gt;onStart-\u0026gt;onStop-\u0026gt;onDestroy 在onResume中：onCreate-\u0026gt;onStart-\u0026gt;onResume-\u0026gt;onPause-\u0026gt;onStop-\u0026gt;onDestroy  Q:finish调用后会立刻调用onStop、onDestroy吗？不会的话,为什么?     不一定会立刻调用 调用finish后会将当前activity加入到ActivityStackSuperVisor的mStopptingActivities集合中,在下一个要启动的activity执行onResume时 会通过idleHandler去调用ActivityStackSuperVisor中处于mStopptingActivities里的activity,所以当要启动的activity在主线程做了很多耗时操作时,就会导致上一个activity的onStop、onDestroy无法立即执行 延迟10s是因为idleHandler的默认延时时长是10s,超过10s就会主动调用上一个activity的onStop  Q:如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？    不会,因为从缓存进程启动App，系统已经缓存了很多信息，很多数据并不会被销毁，onCreate中初始化的那些内容还在，方便用户下次快速启动\nQ:启动一个Dialog,activity生命周期是如何变化的?为什么?    生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView 显示的（没有经过 AMS），所以不会对生命周期有任何影响。\nQ:onSaveInstance是如何实现保持应用状态的?如果在里面传递大量数据会发生什么?     在ActivityThread中会创建一个用于保持状态信息的bundle 在Activity被回收时，会触发一个SaveState的事件。 跟其他的事件一样，SaveState事件从Activity-\u0026gt;Window-\u0026gt;View传递到最大的View，然后遍历View树保存状态 状态保存在一个SparseArray中，以View的ID作为key。 自定义View可以重载onSaveInstanceState()来保存自己的状态，参考TextView的实现方法 在activity进入stop时,会像ActivityManager发出申请,用来保存activity状态,此时就涉及到Binder 传输做一个跨进程的通信将 Bundle 的数据传递给 ActivityManager  传递大数据会报异常\nQ:onResume执行了就可以认为界面对用户可见了?这种理解对吗?    这种理解是错误的,onResume只是系统执行了makeVisiable,而何时将界面绘制完成需要系统具体的绘制后才会知道,当系统回调onWindowFocusChanged=true时才证明界面真正的对用户可见了\nQ:一个activity从创建到用户可见,经历了什么操作,涉及到了哪些生命周期?    onCreate - onStart - onResume - measure - layout -measure - layout - draw - onWindowFocusChanged\n 在onCreate阶段通过setContentView，布局被包装为PhoneWindow内部的DecorView对象 在ActivityThread.handleResumeActivity阶段，执行完performResume后通过WindowManagerImpl的addView，DecorView被 setView 到 ViewRootImpl ViewRootImpl.setView 方法里通过 requestLayout - scheduleTraversals 向 Choreographer 请求安排绘制任务 Choreographer收到VSYNC信号回调到ViewRootImpl的performTraversals对DecorView进行measure、layout、draw，其中由于首次performTraversals会涉及到初始化EGL，所以最终会执行两次该方法，因此decorView会经历：measure - layout - measure - layout draw  Q:什么情况下startActivity需要设置Flag=NEW_TASK?为什么?不设置的话会发生什么?     非activity情况下启动新的activity，比如application和service, 用一个非 Activity 的 Context 去启动一个新的 Activity 的话，新的 Activity 并不知道自己应该放到哪个 Activity 栈中。而设置上 FLAG_ACTIVITY_NEW_TASK 标记，就会直接创建一个 Activity 栈来管理它了。实际上，这样的启动方式就是以 singleTask 模式启动的。 Instrumentation.execStartActivity 执行跳转之前，我们有一个判断条件，当这个条件不成立的时候，会直接抛出运行时异常。  Q:activity从启动到显示,都经历了什么?    Q:activity在屏幕旋转后如何保持下载不中断?    Fragment设置setRetaineInstance保持下载操作\nQ:startActivities是干什么用的?activity栈是如何变化的?    进栈顺序为A-\u0026gt;B-\u0026gt;C，使用startActivities会直接跳转到C,返回时会依次返回C-\u0026gt;B-A\nQ:Activity启动模式与FLAG结合?      FLAG_ACTIVITY_SINGLE_TOP 设置此flag时，当被启动的activity已经位于当前栈的顶部时，则不会新建Activity。\n  FLAG_ACTIVITY_NEW_TASK 此flag是会让Activity在新的栈中启动。但是单独使用此flag时会有较多意想不到的情况发送 使用场景：在非Activity中启动Activity需要强制加上此flag 单独使用此flag的情形：\n Activity的taskAffinity属性的Task栈是否存在 如果存在，要看Activity是否存已经存在于该Task 如果已经存在于该taskAffinity的Task，要看其是不是其rootActivity 如果是其rootActivity，还要看启动该Activity的Intent是否跟当前intent相等    FLAG_ACTIVITY_CLEAR_TASK 此flag需要与FLAG_ACTIVITY_NEW_TASK结合使用。使用时会在Activity启动之前将task中其它Activity销毁(无论其它Activity设置了何种启动模式)\n  FLAG_ACTIVITY_CLEAR_TOP 使用此flag时，如果当前task中存在待启动Activity的实例，则会清空此task中待启动activity及以上的activity\n  Q:Flag使用具体使用?      测试步骤:MainActivity和SercondActivity处在不同task中,使用FLAG_ACTIVITY_NEW_TASK启动SecondActivity MainActivity\u0026ndash;\u0026gt;SecondActivity\u0026ndash;\u0026gt;MainActivity\u0026ndash;\u0026gt;SecondActivity 结果:当第二次尝试进入SecondActivity中时，会发现没有任何变化，仍然停留在MainActivity中 原因分析:因为此时SecondActivity实例已经存在，但是它所在的task的栈顶是ActivityTest；而单独的添加FLAG_ACTIVITY_NEW_TASK又不会\u0026quot;删除task中位于SecondActivity之上的Activity实例\u0026quot;，所以就没有发生跳转(onNewIntent也没有回调)。这种情况下只会将整个栈移动到前台，且栈中的状态不会改变。\n  测试步骤:MainActivity和SercondActivity处在同一个or不同task中,使用FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TOP启动SecondActivity 结果:两个SecondActivity为不同的实例 原因分析:在第二次启动SecondActivity时，会将SecondActivity及以上的activity清空，然后finish并re-create SecondActivity\n  测试步骤:SecondActivity与MainActivity在同一个task中,使用FLAG_ACTIVITY_SINGLE_TOP和FLAG_ACTIVITY_CLEAR_TOP启动SecondActivity MainActivity\u0026ndash;\u0026gt;SecondActivity\u0026ndash;\u0026gt;MainActivity\u0026ndash;\u0026gt;SecondActivity 结果:两个SecondActivity为相同的实例 原因分析:第二次启动SecondActivity时，在当前的task中已经存在SecondActivity的实例，所以第二次启动时，SecondActivity不会被重建，而只会回调onNewIntent方法\n  测试步骤:SecondActivity和MainActivity在不同task中,使用FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TASK启动SecondActivity 结果:两个SecondActivity为不同实例 原因分析:clearTask会清除task上其他activity\n  测试步骤:SecondActivity使用singleInstance启动,MainActivity\u0026ndash;\u0026gt;SecondActivity\u0026ndash;\u0026gt;MainActivity\u0026ndash;\u0026gt;SecondActivity 结果:两个activity在不同task中,第二次SecondActivity与第一次是同一个,会调用onNewIntent方法\n  Q:子线程可以startActivity吗?会有什么问题?    可以,暂时没有发现问题\n"},{"id":2,"href":"/interview/android/","title":"Android","parent":"Interviews","content":""},{"id":3,"href":"/interview/android/%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6/","title":"android整体框架相关","parent":"Android","content":"  Q:进程与应用生命周期之间的关系 Q:系统是如何管理这些进程的? Q:activity启动中都涉及到了哪些类?分别有什么作用？ Q:一个Activity是如何启动的? Q:AMS，Zogyte，App进程，Launcher之间是如何通信的？ Q:为啥Activity启动流程中，大部分都是用Binder通讯，为啥跟Zygote通信的时候要用socket呢？ Q:Android启动流程? Q:ioctl是啥,android哪里用到了? Q:StartActivity的流程?哪里可以做的插件化? Q:startService的启动流程? Q:BindService是什么?为什么 bindService 能和 Activity 的生命周期联动? Q:sendBroadcast原理?什么时候回发生ANR? JobScheduler是什么?有什么用? Q:ANR有哪些场景会发生?   Q:进程与应用生命周期之间的关系     前台进程  它正在用户的互动屏幕上运行一个 Activity（其 onResume() 方法已被调用）。 它有一个 BroadcastReceiver 目前正在运行（其 BroadcastReceiver.onReceive() 方法正在执行）。 它有一个 Service 目前正在执行其某个回调（Service.onCreate()、Service.onStart() 或 Service.onDestroy()）中的代码。   可见进程  它正在运行的 Activity 在屏幕上对用户可见，但不在前台（其 onPause() 方法已被调用）。举例来说，如果前台 Activity 显示为一个对话框，而这个对话框允许在其后面看到上一个 Activity，则可能会出现这种情况。 它有一个 Service 正在通过 Service.startForeground()（要求系统将该服务视为用户知晓或基本上对用户可见的服务）作为前台服务运行。 系统正在使用其托管的服务实现用户知晓的特定功能，例如动态壁纸、输入法服务等。   服务进程  服务流程包含一个已使用 startService() 方法启动的 Service   缓存进程  目前不需要的进程,通常包含用户当前不可见的一个或多个 Activity 实例（onStop() 方法已被调用并返回）    Q:系统是如何管理这些进程的?    这些进程保存在伪 LRU 列表中，列表中的最后一个进程是为了回收内存而终止的第一个进程。此列表的确切排序政策是平台的实现细节，但它通常会先尝试保留更多有用的进程（比如托管用户的主屏幕应用、用户最后看到的 Activity 的进程等），再保留其他类型的进程。\nQ:activity启动中都涉及到了哪些类?分别有什么作用？     Instrumentation:Android Instrumentation是Android系统中的一套控制方法或者“钩子”，这些钩子可以在正常的生命周期（正常是由操作系统控制的）之外控制Android控件的运行,app-\u0026gt;instrumentation-\u0026gt;ams-\u0026gt;app，自动化测试可以通过Instrumentation来操作Activity ActivityThread:ActivityThread不是线程类（Thread），只不过它会跑在ActivityThread.main()方法中,根据Activity管理者的请求调度和执行activities、broadcasts及其相关的操作,每一个新启动的 Activity，其对象实例通过 Class 类的 newInstance 方法创建后，被包裹在一个 ActivityClientRecord 对象中然后添加到进程唯一的 ActivityThread 对象的成员变量 mActivitys 里 ActivityManagerService:Android中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用程序的管理和调度等工作。 ActivityManager:该类提供与Activity、Service和Process相关的信息以及交互方法， 可以被看作是ActivityManagerService的辅助类 ActivityStackSupervisor:负责所有Activity栈的管理。内部管理了mHomeStack、mFocusedStack和mLastFocusedStack三个Activity栈,其中，mHomeStack管理的是Launcher相关的Activity栈；mFocusedStack管理的是当前显示在前台Activity的Activity栈；mLastFocusedStack管理的是上一次显示在前台Activity的Activity栈,负责activiy中launchMode的处理 ActivityStack:ActivityStack负责“Activity栈”的状态和管理，ActivityStack内部包含了多个任务栈（TaskRecord），TaskRecord内部维护了一个ArrayList用来保存和管理ActivityRecord，ActivityRecord包含了一个Activity的所有信息  Q:一个Activity是如何启动的?      Launcher通知AMS启动App的启动页Activity，AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。Launcher进入pause状态后，通知AMS已经paused了，可以启动App了\n  如果App未开启过，AMS发送创建进程请求，Zogyte进程接受AMS请求并孵化应用进程，应用进程调用ActivityThread并调用mian()方法，并且main()方法中创建ActivityThread对象，activityThread.attach()方法中进行绑定（应用进程绑定到AMS），传入applicationThread以便通讯。\n  AMS通知App绑定Application（bindApplication）并启动Activity，并且创建和关联Context,最后调用onCreate等方法。\n  performLaunchActivity方法主要完成几个事情：\n  1.从ActivityClientRecord中获取待启动的Activity的组件信息\n  2.通过Instrumentation的newActivity方法使用类加载器创建Activity对象\n  3.通过LoadedApk的makeApplication方法来尝试创建Application对象（注意没有创建，有了不创建，一个应有只有一个）\n  4.创建Contextimpl对象并通过Activity的attach方法完成一些重要数据的初始化\n  5.调用Activity的onCreate方法\n  Q:AMS，Zogyte，App进程，Launcher之间是如何通信的？     App进程与AMS交互:AMS所在的进程和应用进程在通过Binder互相通信时，实际上都是通过两者的代理类进行通信的,在ActivityThread.attach(false)方法中，AMS绑定ApplicationThread对象，即应用进程绑定到AMS，通过调用AMS的attachApplication来将ActivityThread的内部类ApplicationThread对象绑定至AMS，这样AMS就可以通过这个代理对象来控制应用进程 AMS与Launcher交互:Launcher也是一个App，调用startActivity方法，然后调用的是Instrumentation的execStartActivity方法, Zygote与AMS交互:AMS和Zygote建立Socket连接，然后发送创建应用进程的请求  Q:为啥Activity启动流程中，大部分都是用Binder通讯，为啥跟Zygote通信的时候要用socket呢？     因为他们两个都是 init 进程启动的，两者启动顺序不确定,就算先启动 service manager，也不能保存 zygote 起来的时候 service manger 就已经初始化好了（这就需要额外的同步，太麻烦） 这个 socket 的所有者是 root，group 是 system，只有系统权限的用户才能读写，这又多了一个安全保障（注意，这个 socket 是 Unix 域 socket，不是 internet 域 socket）  Q:Android启动流程?     swapper进程是系统第一个进程,用于初始化进程管理、内存管理、加载各种driver等 init进程是所有用户进程的鼻祖 会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；\\n init进程还启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务\\n init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的 System Server是Zygote孵化的第一个进程\\n Zygote进程孵化出的第一个App进程是Launcher\\n 所有的App进程都是由Zygote进程fork生成的\\n 在Zygote启动时会有一个虚拟机注册过程,会注册一些诸如binder注册等的jni事件  Q:ioctl是啥,android哪里用到了?    ioctl函数是驱动程序里的，用来对设备i/o通道进行管理：对设备的特性进行控制 android中与binder交互用到了ioctl\nQ:StartActivity的流程?哪里可以做的插件化?    lauchModle 检测: ActivityStarter.startActivityUnchecked()\n绕过AndroidManifest检测：\n 瞒天过海：使用代理Activity替换原来的Activity 拿到ActivityManagerNative里面的IActivityManager对象动态代理拦截startActivity函数，获取原来的srcIntent，重新new一个代理Activity的newIntent,newIntent.putExtra(EXTRA_ORIGIN_INTENT,originIntent),然后用newIntent替换原来的srcIntent 借尸还魂: 在Activity实例化之前（laucherActivity的时候），判断intent里面有没有EXTRA_ORIGIN_INTENT字段，如果有的话取出来替换即可拿到ActivityThread对象里面的Handler对象mH,然后拿到new一个Handler的callback，然后适进去，在这个callback里面处理自己的回归需求。（设置callback的原因是因为我们只处理lauchActivy，不影响其他的操作）。这里注意AppCompatActivity需要兼容，先拿到ActivityThread里面的IPackageManager,然后动态代理拦截getActivityInfo()函数的ComponentName替换为代理Activity的 ComponentName  Q:startService的启动流程?    造成ANR可能的原因有Binder full{step 7, 12}, MessageQueue(step 10), AMS Lock (step 13).\nQ:BindService是什么?为什么 bindService 能和 Activity 的生命周期联动?    蓝色代表的是Client进程(发起端), 红色代表的是system_server进程, 黄色代表的是target进程(service所在进程);\nbindService 方法执行时，LoadedApk 会记录 ServiceConnection 信息 Activity 执行 finish 方法时，会通过 LoadedApk 检查 Activity 是否存在未注销/解绑的 BroadcastReceiver 和 ServiceConnection，如果有，那么会通知 AMS 注销/解绑对应的 BroadcastReceiver 和 Service，并打印异常信息，告诉用户应该主动执行注销/解绑的操作\nQ:sendBroadcast原理?什么时候回发生ANR?    ANR时机：只有串行广播才需要考虑超时，因为接收者是串行处理的，前一个receiver处理慢，会影响后一个receiver；并行广播 通过一个循环一次性向所有的receiver分发广播事件，所以不存在彼此影响的问题，则没有广播超时；\n 串行广播超时情况1：某个广播总处理时间 \u0026gt; 2* receiver总个数 * mTimeoutPeriod, 其中mTimeoutPeriod，前台队列默认为10s，后台队列默认为60s; 串行广播超时情况2：某个receiver的执行时间超过mTimeoutPeriod；  JobScheduler是什么?有什么用?    Q:ANR有哪些场景会发生?     当前主线程正在调用的消息耗时严重 已调度的消息发生单点耗时严重 连续多个消息耗时严重 相同消息高频执行 应用进程or系统负载严重  "},{"id":4,"href":"/interview/java/gc/","title":"GC","parent":"Java","content":"  Q:垃圾收集算法? Q:如和判断一个对象是否存活?引用计数法和可达性算法哪个更加好？如何理解一个对象不一定会被回收？   Q:垃圾收集算法?     标记-清除:在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块 标记-整理:让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 复制:将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 分代收集:新生代使用：复制算法,老年代使用：标记 - 清除 或者 标记 - 整理 算法  Q:如和判断一个对象是否存活?引用计数法和可达性算法哪个更加好？如何理解一个对象不一定会被回收？       引用计数法   所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收. 引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。   2.可达性算法(引用链法)  该算法的思想是：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。 在java中可以作为GC Roots的对象有以下几种:  虚拟机栈中引用的对象 方法区类静态属性引用的对象 方法区常量池引用的对象 本地方法栈JNI引用的对象     如何理解一个对象不一定会被回收？  虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达GC Root时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记 如果对象在可达性分析中没有与GCRoot的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的对队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。    "},{"id":5,"href":"/interview/android/glide/","title":"Glide","parent":"Android","content":"  Q:Glide优势? Q:自己实现一个图片加载框架,需要考虑什么? Q:Glide中这几个点都是如何实现的?   Q:Glide优势?     多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video） 生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求） 高效处理Bitmap（bitmap的复用和主动回收，减少系统回收压力） 高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半）  Q:自己实现一个图片加载框架,需要考虑什么?     异步加载：线程池 切换线程：Handler，没有争议吧 缓存：LruCache、DiskLruCache 防止OOM：软引用、LruCache、图片压缩、Bitmap像素存储位置 内存泄露：注意ImageView的正确引用，生命周期管理 列表滑动加载的问题：加载错乱、队满任务过多问题  Q:Glide中这几个点都是如何实现的?     异步加载  private GlideExecutor sourceExecutor; //加载源文件的线程池，包括网络加载  private GlideExecutor diskCacheExecutor; //加载硬盘缓存的线程池  ... private GlideExecutor animationExecutor; //动画线程池 "},{"id":6,"href":"/interview/java/io/","title":"I/O","parent":"Java","content":"  Q:Java中的I/O可以分为几类? Q:NIO和普通I/O区别? Q:字符流和字节流有什么区别？如何选择字节流或者字符流？什么是缓冲区，有什么作用？   Q:Java中的I/O可以分为几类?     磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO  Q:NIO和普通I/O区别?     NIO 是非阻塞的；只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义 NIO 面向块，I/O 面向流。  Q:字符流和字节流有什么区别？如何选择字节流或者字符流？什么是缓冲区，有什么作用？     区别:  字符流和字节流的使用非常相似，但是实际上字节流的操作不会经过缓冲区（内存）而是直接操作文本本身的，而字符流的操作会先经过缓冲区（内存）然后通过缓冲区再操作文件 字符流是对字节流的包装   如何选择字节流或者字符流？  字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的 如果是音频文件、图片、歌曲，就用字节流好点（避免数据丢失） 如果是关系到中文（文本）的，用字符流好点   什么是缓冲区，有什么作用？  缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就显著提升了性能。 对于 Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓冲区刷新到文件则可以使用 flush() 方法操作    "},{"id":7,"href":"/interview/","title":"Interviews","parent":"十万个为什么","content":""},{"id":8,"href":"/interview/java/","title":"Java","parent":"Interviews","content":""},{"id":9,"href":"/interview/java/jvm/","title":"JVM","parent":"Java","content":"  Q:jvm的内存模型是啥样的? Q:类的加载过程? Q:Class.forName() 和ClassLoader.loadClass()区别？实际开发你用那种，为什么？ Q:说一下对象的创建过程？变量创建过程种放在虚拟机哪里？ Q:什么情况下会触发类的初始化? Q:什么是双亲委派模型?有什么优势? Q:为什么会出现破坏双亲委派的模型？是解决了什么问题？ Q:基本数据类型一定存储在栈中吗？ Q:泛型是什么? Q:泛型通配符? Q:泛型擦除是什么?存在什么问题?有哪些补救方案?应用场景是哪些？ Q：泛型和反射有何联系？使用反射来获取泛型信息？getType和getGenericType有何区别？ Q:为什么说反射的效率低? Q:HashCode为什么使用31作为乘数? Q:static变量存储位置是哪里？静态变量的生命周期？静态变量何时销毁？静态引用的对象回收如何理解？ Q:什么是绑定？静态和动态绑定如何区别？动态绑定编译原理是什么？动态绑定运行原理是什么？ Q:为什么内部类调用的局部变量必须是final修饰的？局部变量对垃圾回收机制有什么样的影响？ Q:什么是多态?多态有哪些弊端？Java实现多态有哪些必要条件？什么是向上、向下转型? Q:常见代码块有哪些?执行顺序是什么样子的？ Q:带有类名.变量加载时,加载顺序是怎么样的? Q:Java数据类型有哪些？什么是值传递？什么是引用传递？如何理解值传递和引用传递，以及它们有何区别？   Q:jvm的内存模型是啥样的?     程序计数器:在jvm中，它就是程序控制流的指示器，循环，跳转，异常处理，线程的恢复等工作都需要依赖程序计数器去完成,此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域 虚拟机栈:在每个方法执行的时候，jvm都会同步创建一个栈帧去存储局部变量表，操作数栈，动态连接，方法返回值等信息。一个方法的生命周期就贯彻了一个栈帧从入栈到出栈的全部过程。局部变量表应该是我们接触的最多的，里面存储了java的8大基本数据类型（byte、short、char、int、float、long、double、boolean）、对象引用(reference类型，不是对象本身，是指向对象的引用)和returnAddress类型（指向一条字节码指令的地址）， 本地方法栈:native方法栈 堆:所有线程共享的一块内存区域，用于存放几乎所有的对象实例和数组，TLAB是线程私有的，在堆空间中分配，对象会首先存放在这个线程私有的TLAB中，可以提升线程分配的效率 方法区:方法区也是所有线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。运行时常量池就是方法区的一部分，代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用,Java语言并不要求常量一定只有编译期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法  Q:类的加载过程?    加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，是依次有序的。但是解析阶段有可能会在初始化之后才会进行，这是为了支持java动态绑定的特性\nQ:Class.forName() 和ClassLoader.loadClass()区别？实际开发你用那种，为什么？     Class.forName() 和ClassLoader.loadClass()区别？  Class.forName() 默认执行类加载过程中的连接与初始化动作，一旦执行初始化动作，静态变量就会被初始化为程序员设置的值，如果有静态代码块，静态代码块也会被执行 ClassLoader.loadClass() 默认只执行类加载过程中的加载动作，后面的动作都不会执行    Q:说一下对象的创建过程？变量创建过程种放在虚拟机哪里？     说一下对象的创建过程？比如：Dog dog= new Dog()；  当虚拟机执行到new指令时，它先在常量池中查找“Dog”，看能否定位到Dog类的符号引用；如果能，说明这个类已经被加载到方法区了，则继续执行。如果没有，就让Class Loader先执行类的加载。 然后，虚拟机开始为该对象分配内存，对象所需要的内存大小在类加载完成后就已经确定了。这时候只要在堆中按需求分配空间即可。具体分配内存时有两种方式，第一种，内存绝对规整，那么只要在被占用内存和空闲内存间放置指针即可，每次分配空间时只要把指针向空闲内存空间移动相应距离即可，当某对象被GC回收后，则需要进行某些对象内存的迁移。第二种，空闲内存和非空闲内存夹杂在一起，那么就需要用一个列表来记录堆内存的使用情况，然后按需分配内存。 对于多线程的情况，如何确保一个线程分配了对象内存但尚未修改内存管理指针时，其他线程又分配该块内存而覆盖的情况？有一种方法，就是让每一个线程在堆中先预分配一小块内存（TLAB本地线程分配缓冲），每个线程只在自己的内存中分配内存。但对象本身按其访问属性是可以线程共享访问的。 内存分配到后，虚拟机将分配的内存空间都初始化为零值(不包括对象头)。实例变量按变量类型初始化相应的默认值（数值型为0，boolan为false），所以实例变量不赋初值也能使用。接着设置对象头信息，比如对象的哈希值，GC分代年龄等。 从虚拟机角度，此时一个新的对象已经创建完成了。但从我们程序运行的角度，新建对象才刚刚开始，对象的构造方法还没有执行。只有执行完构造方法，按构造方法进行初始化后，对象才是彻底创建完成了。构造函数的执行还涉及到调用父类构造器，如果没有显式声明调用父类构造器，则自动添加默认构造器。 new运算符可以返回堆中这个对象的引用   变量创建过程种放在虚拟机哪里？  变量是实例变量、局部变量或静态变量的不同将引用放在不同的地方：  如果dog局部变量，dog变量在栈帧的局部变量表，这个对象的引用就放在栈帧。 如果dog是实例变量，dog变量在堆中，对象的引用就放在堆。 如果dog是静态变量，dog变量在方法区，对象的引用就放在方法区。      Q:什么情况下会触发类的初始化?     遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令； 使用 java.lang.reflect 包的方法对类进行反射调用的时候；（这里可能就会出现面试题，反射的缺点是什么） 当初始化一个类的时候，发现其父类还没有进行初始化的时候，需要先触发其父类的初始化； 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个类； 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有初始化。 使用java8新加入的default默认方法，如果这个接口的实现类发生了初始化，那么该接口要在其之前被初始化。  Q:什么是双亲委派模型?有什么优势?    双亲委派模型就是说一个类加载器收到了类加载的请求，不会自己先加载，而是把它交给自己的父类去加载，层层迭代,优势就是所有的类都会交给顶层父类加载器去实现,这样就实现了jvm中类的唯一性\nQ:为什么会出现破坏双亲委派的模型？是解决了什么问题？    Q:基本数据类型一定存储在栈中吗？     首先说明，\u0026ldquo;java中的基本数据类型一定存储在栈中的吗？”这句话肯定是错误的。 基本数据类型是放在栈中还是放在堆中，这取决于基本类型在何处声明，下面对数据类型在内存中的存储问题来解释一下：  一：在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因  在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在JAVA虚拟机栈中。当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在JAVA虚拟机的栈中，该变量所指向的对象是放在堆类存中的。   二：在类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。同样在类中声明的变量即可是基本类型的变量，也可是引用类型的变量  当声明的是基本类型的变量其变量名及其值放在堆内存中的。引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中      Q:泛型是什么?    泛型就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法,好处就是它不再需要对取出来的结果进行强制转换了 出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如：\nT 代表一般的任何类。 E 代表 Element 的意思，或者 Exception 异常的意思。 K 代表 Key 的意思。 V 代表 Value 的意思，通常与 K 一起配合使用。 S 代表 Subtype 的意思，文章后面部分会讲解示意 Q:泛型通配符?            Q:泛型擦除是什么?存在什么问题?有哪些补救方案?应用场景是哪些？    List\u0026lt;String\u0026gt; l1 = new ArrayList\u0026lt;String\u0026gt;(); List\u0026lt;Integer\u0026gt; l2 = new ArrayList\u0026lt;Integer\u0026gt;(); System.out.println(l1.getClass() == l2.getClass()); // true 在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 则会被转译成普通的 Object 类型，如果指定了上限如 则类型参数就被替换成类型上限 类型擦除，是泛型能够与之前的 java 版本代码兼容共存的原因,用反射的手段就绕过了正常开发中编译器不允许的操作限制\nQ：泛型和反射有何联系？使用反射来获取泛型信息？getType和getGenericType有何区别？      通过反射中使用泛型，可以避免使用反射生成的对象需要强制类型转换\n  泛型的好处众多，最主要的一点就是避免类型转换，防止出现ClassCastException，即类型转换异常。\npublic class ObjectFactory { public static \u0026lt;T\u0026gt; T getInstance(Class\u0026lt;T\u0026gt; cls) { try { // 返回使用该Class对象创建的实例 return cls.newInstance(); } catch (InstantiationException | IllegalAccessException e) { e.printStackTrace(); return null; } } }  在上面程序的getInstance()方法中传入一个Class\u0026lt;T\u0026gt;参数，这是一个泛型化的Class对象，调用该Class对象的newInstance()方法将返回一个T对象。  String instance = ObjectFactory.getInstance(String.class);  通过传入String.class便知道T代表String，所以返回的对象是String类型的，避免强制类型转换。当然Class类引入泛型的好处不止这一点，在以后的实际应用中会更加能体会到。    直接使用Field的getType()方法只能获取普通类型的Field的数据类型：对于增加了泛型参数的类型的 Field，应该使用 getGenericType() 方法来取得其类型 ``` public class GenericTest{ private Map\u0026lt;String , Integer\u0026gt; score;\n public static void main(String[] args) throws Exception{ Class\u0026lt;GenericTest\u0026gt; clazz = GenericTest.class; Field f = clazz.getDeclaredField(\u0026quot;score\u0026quot;); // 直接使用getType()取出Field类型只对普通类型的Field有效 Class\u0026lt;?\u0026gt; a = f.getType(); // 下面将看到仅输出java.util.Map System.out.println(\u0026quot;score的类型是:\u0026quot; + a); // 获得Field实例f的泛型类型 Type gType = f.getGenericType(); // 如果gType类型是ParameterizedType对象 if(gType instanceof ParameterizedType){ // 强制类型转换 ParameterizedType pType = (ParameterizedType)gType; // 获取原始类型 Type rType = pType.getRawType(); System.out.println(\u0026quot;原始类型是：\u0026quot; + rType); // 取得泛型类型的泛型参数 Type[] tArgs = pType.getActualTypeArguments(); System.out.println(\u0026quot;泛型类型是:\u0026quot;); for (int i = 0; i \u0026lt; tArgs.length; i++) { System.out.println(\u0026quot;第\u0026quot; + i + \u0026quot;个泛型类型是：\u0026quot; + tArgs[i]); } } else{ System.out.println(\u0026quot;获取泛型类型出错！\u0026quot;); } } } ``` - 输出结果： \u0026gt; score 的类型是: interface java.util.Map \u0026gt; 原始类型是: interface java.util.Map \u0026gt; 泛型类型是: \u0026gt; 第 0 个泛型类型是: class java.lang.String \u0026gt; 第 1 个泛型类型是：class java.lang.Integer    Q:为什么说反射的效率低?     Method#invoke方法的参数是Object[],所以在调用时会对参数做封装和解封操作,会产生大量临时对象 需要检查方法可见性 需要校验参数 反射方法难以内联 JIT难以优化  Q:HashCode为什么使用31作为乘数?     是一个奇质数，如果选择偶数会导致乘积运算时数据溢出。 另外在二进制中，2个5次方是32，那么也就是 31 * i == (i \u0026laquo; 5) - i。这主要是说乘积运算可以使用位移提升性能，同时目前的JVM虚拟机也会自动支持此类的优化。 减少碰撞概率  Q:static变量存储位置是哪里？静态变量的生命周期？静态变量何时销毁？静态引用的对象回收如何理解？     static变量存储位置  注意是：存储在JVM的方法区中 static变量在类加载时被初始化，存储在JVM的方法区中，整个内存中只有一个static变量的拷贝，可以使用类名直接访问，也可以通过类的实例化对象访问，一般不推荐通过实例化对象访问，通俗的讲static变量属于类，不属于对象，任何实例化的对象访问的都是同一个static变量，任何地放都可以通过类名来访问static变量。   静态变量的生命周期  当我们启动一个app的时候，系统会创建一个进程，此进程会加载一个Dalvik VM的实例，然后代码就运行在DVM之上，类的加载和卸载，垃圾回收等事情都由DVM负责。也就是说在进程启动的时候，类被加载，静态变量被分配内存。   静态变量何时销毁  类在什么时候被卸载？在进程结束的时候。 说明：一般情况下，所有的类都是默认的ClassLoader加载的，只要ClassLoader存在，类就不会被卸载，而默认的ClassLoader生命周期是与进程一致的   静态引用的对象回收  只要静态变量没有被销毁也没有置null，其对象一直被保持引用，也即引用计数不可能是0，因此不会被垃圾回收。因此，单例对象在运行时不会被回收    Q:什么是绑定？静态和动态绑定如何区别？动态绑定编译原理是什么？动态绑定运行原理是什么？     什么是绑定？  把一个方法与其所在的类/对象 关联起来叫做方法的绑定。绑定分为静态绑定（前期绑定）和动态绑定（后期绑定）。   静态和动态绑定如何区别？  静态绑定（前期绑定）是指：  在程序运行前就已经知道方法是属于那个类的，在编译的时候就可以连接到类的中，定位到这个方法。 在Java中，final、private、static修饰的方法以及构造函数都是静态绑定的，不需程序运行，不需具体的实例对象就可以知道这个方法的具体内容。   动态绑定（后期绑定）是指：  在程序运行过程中，根据具体的实例对象才能具体确定是哪个方法。 动态绑定是多态性得以实现的重要因素，它通过方法表来实现：每个类被加载到虚拟机时，在方法区保存元数据，其中，包括一个叫做 方法表（method table）的东西，表中记录了这个类定义的方法的指针，每个表项指向一个具体的方法代码。如果这个类重写了父类中的某个方法，则对应表项指向新的代码实现处。从父类继承来的方法位于子类定义的方法的前面。     动态绑定编译原理  我们假设 Father ft=new Son(); ft.say(); Son继承自Father，重写了say()。 编译：我们知道，向上转型时，用父类引用执行子类对象，并可以用父类引用调用子类中重写了的同名方法。但是不能调用子类中新增的方法，为什么呢？ 因为在代码的编译阶段，编译器通过 声明对象的类型（即引用本身的类型） 在方法区中该类型的方法表中查找匹配的方法（最佳匹配法：参数类型最接近的被调用），如果有则编译通过。（这里是根据声明的对象类型来查找的，所以此处是查找 Father类的方法表，而Father类方法表中是没有子类新增的方法的，所以不能调用。） 编译阶段是确保方法的存在性，保证程序能顺利、安全运行。   动态绑定运行原理是什么？  运行：我们又知道，ft.say()调用的是Son中的say()，这不就与上面说的，查找Father类的方法表的匹配方法矛盾了吗？不，这里就是动态绑定机制的真正体现。 上面编译阶段在 声明对象类型 的方法表中查找方法，只是为了安全地通过编译（也为了检验方法是否是存在的）。而在实际运行这条语句时，在执行 Father ft=new Son(); 这一句时创建了一个Son实例对象，然后在 ft.say() 调用方法时，JVM会把刚才的son对象压入操作数栈，用它来进行调用。而用实例对象进行方法调用的过程就是动态绑定：根据实例对象所属的类型去查找它的方法表，找到匹配的方法进行调用。我们知道，子类中如果重写了父类的方法，则方法表中同名表项会指向子类的方法代码；若无重写，则按照父类中的方法表顺序保存在子类方法表中。故此：动态绑定根据对象的类型的方法表查找方法是一定会匹配（因为编译时在父类方法表中以及查找并匹配成功了，说明方法是存在的。这也解释了为何向上转型时父类引用不能调用子类新增的方法：在父类方法表中必须先对这个方法的存在性进行检验，如果在运行时才检验就容易出危险——可能子类中也没有这个方法）.   两者之间区分  程序在JVM运行过程中，会把类的类型信息、static属性和方法、final常量等元数据加载到方法区，这些在类被加载时就已经知道，不需对象的创建就能访问的，就是静态绑定的内容；需要等对象创建出来，使用时根据堆中的实例对象的类型才进行取用的就是动态绑定的内容。    Q:为什么内部类调用的局部变量必须是final修饰的？局部变量对垃圾回收机制有什么样的影响？     为什么内部类调用的外部变量必须是final修饰的？  简单解答：一方面，由于方法中的局部变量的生命周期很短，一旦方法结束变量就要被销毁，为了保证在内部类中能找到外部局部变量，通过final关键字可得到一个外部变量的引用；另一方面，通过final关键字也不会在内部类去做修改该变量的值，保护了数据的一致性。 详细一点可以这样说：因为生命周期的原因。方法中的局部变量，方法结束后这个变量就要释放掉，final保证这个变量始终指向一个对象。首先，内部类和外部类其实是处于同一个级别，内部类不会因为定义在方法中就会随着方法的执行完毕而跟随者被销毁。问题就来了，如果外部类的方法中的变量不定义final，那么当外部类方法执行完毕的时候，这个局部变量肯定也就被GC了，然而内部类的某个方法还没有执行完，这个时候他所引用的外部变量已经找不到了。如果定义为final，java会将这个变量复制一份作为成员变量内置于内部类中，这样的话，由于final所修饰的值始终无法改变，所以这个变量所指向的内存区域就不会变。 为了解决：局部变量的生命周期与局部内部类的对象的生命周期的不一致性问题 注意：在java 1.8中，可以不用final修饰，但是千万不要被误导，因为你不用final修饰，在匿名内部类中修改它的值还是会导致编译报错。因为java 1.8其实会自动给它加上final   局部变量对垃圾回收机制有什么样的影响？  先说出结论：局部变量表中的变量是很重要的垃圾回收根节点，被局部变量表中变量直接或者间接引用的对象都不会被回收    Q:什么是多态?多态有哪些弊端？Java实现多态有哪些必要条件？什么是向上、向下转型?     什么是多态？  多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。   Java实现多态的必要条件?  Java实现多态有三个必要条件：继承、重写、向上转型。 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。   向上、向下转型?  class Demo_SuperMan { public static void main(String[]args){ Person p=new SuperMan();//父类引用指向子类对象。超人提升为了人 //父类引用指向子类对象，就是向上转型 System.out.println(p.name); //John p.Tsy();//子类Tsy //p.Fly();//找不到该方法 SuperMan sm=(SuperMan)p;//向下转型,看到整个对象的内容 System.out.println(sm.name);//SuperName sm.Fly();//飞出去救 } } class Person{ String name=\u0026quot;John\u0026quot;; public void Tsy(){ System.out.println(\u0026quot;Tsy\u0026quot;); } } class SuperMan extends Person{ String name=\u0026quot;SuperName\u0026quot;; @Override public void Tsy(){ System.out.println(\u0026quot;子类Tsy\u0026quot;); } public void Fly(){ System.out.println(\u0026quot;飞出去救人\u0026quot;); } }   Q:常见代码块有哪些?执行顺序是什么样子的？     a:局部代码块  在方法中出现；限定变量生命周期，及早释放，提高内存利用率   b:构造代码块  在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行   c:静态代码块  在类中方法外出现，加了static修饰 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次    Q:带有类名.变量加载时,加载顺序是怎么样的?     当遇到 类名.变量 加载时，只加载变量所在类。 当遇到new加载类时，先执行父类，在执行子类。 在同一个类中，代码块比构造方法先执行。  Q:Java数据类型有哪些？什么是值传递？什么是引用传递？如何理解值传递和引用传递，以及它们有何区别？     Java数据类型有哪些？  Java中的数据类型分为两种为基本类型和引用类型。  1、基本类型的变量保存原始值，所以变量就是数据本身。  常见的基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress。   2、引用类型的变量保存引用值，所谓的引用值就是对象所在内存空间的“首地址值”，通过对这个引用值来操作对象。  常见的引用类型：类类型，接口类型和数组。     基本类型(primitive types)  primitive types 包括boolean类型以及数值类型（numeric types）。numeric types又分为整型（integer types）和浮点型（floating-point type）。整型有5种：byte short int long char(char本质上是一种特殊的int)。浮点类型有float和double。   引用类型(reference types)  ①接口 ②类 ③数组     什么是值传递？  在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。 比如String类，设计成不可变的，所以每次赋值都是重新创建一个新的对象，因此是值传递！   什么是引用传递？  引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间。 引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。 在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。   如何理解值传递和引用传递，以及它们有何区别？  看下面代码案例 private void test1(){ Demo demo = new Demo(); demo.change(demo.str, demo.ch); Log.d(\u0026quot;yc---\u0026quot;,demo.str); Log.d(\u0026quot;yc---\u0026quot;, Arrays.toString(demo.ch)); //打印值 //yc---: hello //yc---: [c, b] } public class Demo { String str = new String(\u0026quot;hello\u0026quot;); char[] ch = {'a', 'b'}; public void change(String str, char[] ch) { str = \u0026quot;ok\u0026quot;; ch[0] = 'c'; } }  案例过程分析  为对象分配空间     执行change()方法  执行前实参（黑色）和形参（红色）的指向如下：    最后打印  因为String是不可变类且为值传递，而ch[]是引用传递，所以方法中的str = \u0026ldquo;ok\u0026rdquo;,相当于重新创建一个对象并没有改变实参str的值，数组是引用传递，直接改变，所以执行完方法后，指向关系如下：        通过上面的分析我们可以得出以下结论：  基本数据类型传值，对形参的修改不会影响实参； 引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象。 String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。   如何理解引用类型的按值传递？  引用类型的按值传递，传递的是对象的地址。只是得到元素的地址值，并没有复制元素。比如数组，就是引用传递，假如说是值传递，那么在方法调用赋值中，将实参的值复制一份传递到函数中将会非常影响效率    Q:Java中代理有几种方式?各有什么特点?     静态代理  编译成class文件,通过接口实现    public interface IUserDao { public void save(); } public class UserDao implements IUserDao{ @Override public void save() { System.out.println(\u0026#34;保存数据\u0026#34;); } } public class UserDaoProxy implements IUserDao{ private IUserDao target; public UserDaoProxy(IUserDao target) { this.target = target; } @Override public void save() { System.out.println(\u0026#34;开启事务\u0026#34;);//扩展了额外功能  target.save(); System.out.println(\u0026#34;提交事务\u0026#34;); } } public class StaticUserProxy { @Test public void testStaticProxy(){ //目标对象  IUserDao target = new UserDao(); //代理对象  UserDaoProxy proxy = new UserDaoProxy(target); proxy.save();//开启事务、保存数据、提交事务  } }  动态代理  动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中    动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中 特点： 动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。 JDK中生成代理对象主要涉及的类有 java.lang.reflect Proxy，主要方法为 static Object newProxyInstance(ClassLoader loader, //指定当前目标对象使用类加载器  Class\u0026lt;?\u0026gt;[] interfaces, //目标对象实现的接口的类型  InvocationHandler h //事件处理器 ) //返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。 java.lang.reflect InvocationHandler，主要方法为 Object invoke(Object proxy, Method method, Object[] args) // 在代理实例上处理方法调用并返回结果。 举例：保存用户功能的动态代理实现 接口类： IUserDao package com.proxy; public interface IUserDao { public void save(); } 目标对象：UserDao package com.proxy; public class UserDao implements IUserDao{ @Override public void save() { System.out.println(\u0026#34;保存数据\u0026#34;); } } 动态代理对象：UserProxyFactory package com.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class ProxyFactory { private Object target;// 维护一个目标对象  public ProxyFactory(Object target) { this.target = target; } // 为目标对象生成代理对象  public Object getProxyInstance() { return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;开启事务\u0026#34;); // 执行目标对象方法  Object returnValue = method.invoke(target, args); System.out.println(\u0026#34;提交事务\u0026#34;); return null; } }); } } "},{"id":10,"href":"/interview/android/recyclerview/","title":"RecyclerView","parent":"Android","content":"  Q:RecyclerView中onLayout有哪些步骤流程? Q:RecyclerView中是如何获取ViewHolder的？有哪些步骤流程? Q:什么是pre-layout?什么时候调用? Q:stableID是什么？有什么作用? Q:什么是Scrap？设计思想是什么? Q:mChangedScrap 和 mAttachedScrap区别? Q:如何实现RecyclerView的拖拽排序? Q:当item超过一定数量，如何正确的设置RecyclerView的maxHeight？ Q:RecyclerView中的复用的几个问题 Q:RecyclerView回收些什么? Q:RecyclerView中的ViewHolder回收到哪里去? Q:什么情况下,会调用bindViewHolder? Q:RecyclerView卡片中持有的资源，到底该什么时候释放？ Q:RecyclerView中各级缓存的用途?各存储结构是什么样的? Q:如何设计一个RecyclerView的item点击事件? Q:RecyclerView的预加载是什么? Q:RecyclerView为什么进行预布局? Q:如何实现RecyclerView的局部更新，用过payload吗,notifyItemChange方法中的参数   Q:RecyclerView中onLayout有哪些步骤流程?    RecyclerView.onLayout(...) //布局放置 -\u0026gt;RecyclerView.dispatchLayout() //dispatchLayoutStep1方法等同于pre layout,预布局阶段,记录ViewHolder位置信息；;  -\u0026gt;RecyclerView.dispatchLayoutStep1() ///dispatchLayoutStep2方法处理真正布局的地方  -\u0026gt;RecyclerView.dispatchLayoutStep2() //开启动画阶段  -\u0026gt;RecyclerView.dispatchLayoutStep3() -\u0026gt;RecyclerView.dispatchLayoutStepX() //mLayout是LayoutManager的实例\\  -\u0026gt;mLayout.onLayoutChildren(mRecycler, mState);\\ //此处查看LinearLayoutManager.fill() 注释：填充给定Layout\\  -\u0026gt;LinearLayoutManager.fill(recycler, mLayoutState, state, false);\\ //循环调用，每次返回一个\\  -\u0026gt;LinearLayoutManager.layoutChunk(recycler, layoutState) \\ -\u0026gt;LinearLayoutManager.LayoutState.next()\\ //通过 Recycler 获取指定位置的 ItemView\\  -\u0026gt;RecyclerView.recycler.getViewForPosition(int position)\\ //获取ViewHolder 返回ViewHolder中的ItemView,在这里决定是onCreateView还是bindView\\  -\u0026gt;RecyclerView.tryGetViewHolderForPositionByDeadline(***) Q:RecyclerView中是如何获取ViewHolder的？有哪些步骤流程?     如果是预布局，尝试从mChangedScrap 中获取ViewHolder 尝试从mAttachedScrap/mHiddenViews/mCachedViews 中获取ViewHolder 如果存在StableId 尝试使用ID从mAttachedScrap中获取ViewHolder 如果用户有自定义缓存，尝试从mViewCacheExtension中获取ViewHolder，一般不会自定义 尝试从mRecyclerPool中获取ViewHolder 如果以上方法均未获取到则创建一个ViewHolder  Q:什么是pre-layout?什么时候调用?    当adapter调用notifyItemChanged()或者notifyItemRangeChanged()的时候，onLayoutChildren()会调用两次，一次是预布局，一次是实际布局。通过对比两次布局的不同，RecyclerView可以完成预测动画。\nQ:stableID是什么？有什么作用?    stableID 作用在于调用notifyDataSetChanged方法后，LayoutManager重新布局的的时候将ViewHolder回收到何处 没有设置StableId，viewHolder被回收到RecyclerViewPool 如果设置了StableId，viewHolder被回收到Scrap中\nQ:什么是Scrap？设计思想是什么?    mChangedScrap 和 mAttachedScrap 是RecyclerView最先查找ViewHolder的地方， 只在布局阶段使用，布局完成后这两个地方的ViewHolder会移到mCachedViews 或者mRecyclerPool中。\nQ:mChangedScrap 和 mAttachedScrap区别?     添加时机不同，只有在Item发生了变化（notifyItemChanged或者notifyItemRangeChanged被调用），并且ItemAnimator调用canReuseUpdatedViewHolder()返回false时才会添加到mAttachedScrap，否则添加到mChangedScrap中 CanReuseUpdateViewHolder返回‘false’表示要使用不同的ViewHolder来完成动画，true表示使用相同的ViewHolder完成动画例如淡入淡出 mChangedScrap 只在预布局的时候会使用到，mAttachedScrap在整个布局中都可以使用  Q:如何实现RecyclerView的拖拽排序?    ItemTouchHelper\nQ:当item超过一定数量，如何正确的设置RecyclerView的maxHeight？    重写Layoutmanager的isAutoMeasureEnabled,当超过maxHeight时自己进行measure\nQ:RecyclerView中的复用的几个问题      复用什么？ 在RV中,复用的是ViewHolder\n  从哪里获得复用？优先级如何? Recycler有4个层次用于缓存 ViewHolder 对象，优先级从高到底依次为mAttachedScrap、mCachedViews、mViewCacheExtension、mRecyclerPool。如果四层缓存都未命中，则重新创建并绑定 ViewHolder 对象,RecycledViewPool 对 ViewHolder 按viewType分类存储（通过SparseArray），同类 ViewHolder 存储在默认大小为5的ArrayList中\n  什么时候复用？从mRecyclerPool中复用的ViewHolder ，只能复用于viewType相同的表项，从mCachedViews中复用的 ViewHolder ，只能复用于指定位置的表项。mCachedViews用于缓存指定位置的 ViewHolder,会将viewHolder放入mRecyclerPool中 ，只有“列表回滚”这一种场景（刚滚出屏幕的表项再次进入屏幕），才有可能命中该缓存。该缓存存放在默认大小为 2 的ArrayList中\n  Q:RecyclerView回收些什么?    回收那些子view顶部距离limit线超过view高度的view Limit线可以理解为列表滑动停止后,列表顶部的位置\nQ:RecyclerView中的ViewHolder回收到哪里去?    滑出屏幕表项对应的 ViewHolder 会被回收到mCachedViews+mRecyclerPool 结构中 mCachedViews是 ArrayList ，默认存储最多2个 ViewHolder ，当它放不下的时候，按照先进先出原则将最先进入的 ViewHolder 存入回收池的方式来腾出空间。mRecyclerPool 是 SparseArray ，它会按viewType分类存储 ViewHolder ，默认每种类型最多存5个。\n 从mAttachedScrap 中复用的 ViewHolder 不需要重新创建也不需要重新绑定数据 从mCachedViews中复用的 ViewHolder 不需要重新绑定数据,不满足holder.isBound 从mRecyclerPool中复用的 ViewHolder 需要重新绑定数据  Q:什么情况下,会调用bindViewHolder?    满足!holder.isBound() || holder.needsUpdate() || holder.isInvalid()\nQ:RecyclerView卡片中持有的资源，到底该什么时候释放？    在onViewRecycled中进行释放,因为这是标明item已经进入mRecyclerPool了，重新进入时会bind数据\nQ:RecyclerView中各级缓存的用途?各存储结构是什么样的?     mAttachedScrap：用于布局过程中屏幕可见表项的回收和复用。没有大小限制，但最多包含屏幕可见表项,ArrayList mCachedViews：用于移出屏幕表项的回收和复用，且只能用于指定位置的表项，有点像“回收池预备队列”，即总是先回收到mCachedViews，当它放不下的时候，按照先进先出原则将最先进入的ViewHolder存入回收池。ArrayList mRecyclerPool：用于移出屏幕表项的回收和复用，且只能用于指定viewType的表项,对ViewHolder按viewType分类存储在SparseArray中，同类ViewHolder存储在ScrapData中的ArrayList中  Q:如何设计一个RecyclerView的item点击事件?     层层传递点击监听回调,在viewHolder中绑定onClick事件 将点击坐标转化成表项索引 通过GestureDetector监听onSingleTapUp事件,然后仿照AbsListView.pointToPosition()中的做法,将触摸点坐标通过getHitRect转换成点击位置position  Q:RecyclerView的预加载是什么?    根据recyclerView的滑动方向,提前加载item内容\nQ:RecyclerView为什么进行预布局?    为了进行表项动画的展示\n  RecyclerView 为了实现表项动画，进行了 2 次布局，第一次预布局，第二次后布局，在源码上表现为 LayoutManager.onLayoutChildren() 被调用 2 次。\n  预布局的过程始于 RecyclerView.dispatchLayoutStep1()，终于 RecyclerView.dispatchLayoutStep2()。\n  Q:如何实现RecyclerView的局部更新，用过payload吗,notifyItemChange方法中的参数    payload参数可以认为是你要刷新的一个标示，比如我有时候只想刷新itemView中的textview,有时候只想刷新imageview？又或者我只想某一个view的文字颜色进行高亮设置？那么我就可以通过payload参数来标示这个特殊的需求了\n"},{"id":11,"href":"/interview/android/view/","title":"View","parent":"Android","content":"  Q:View.getContext()一定会返回activity对象吗? Q:View.inflate和LayoutInflater.inflate方法区别？ Q:Inflate的三个参数(int resource, ViewGroup root, boolean attachToRoot),组合设置后分别有什么效果? Q:子线程中可以更新UI吗?为什么? Q:View坐标体系是什么? Q:为什么setTranslation会移动View的位置? Q:为什么View移动的位置跟mScrollX，mScrollY是相反的? Q:都有什么获取view区域的方法?怎么用? Q:View的绘制流程分几步，从哪开始？哪个过程结束以后能看到view？ Q:View什么时候发生绘制? Q:ViewGroup有onMeasure方法吗？为什么? Q:setContentView之后发生了什么？ Q:setContentView可以在其他生命周期内执行吗?为什么? Q:view、drawable、bitmap之间的关系? Q:有了view，为什么还要设计drawable? Q:如何设计一个曝光系统?需要注意些什么? Q:有用过LayoutInflater.Factory吗？都有哪些应用场景? Q:SurfaceView是什么?有哪些应用场景? Q:一个viewGroup 绘制了4-5个view，当其中一个子view。例如背景变了。就会导致整个viewGroup的刷新。。请问有没有办法？仅仅只让对应的view更改UI。避免让viewGroup重新测量 绘制? Q:在绘制阶段，ViewGroup 不光要绘制自身，还需循环绘制其一众子 View，这个绘制策略默认为顺序绘制，即 [0 ~ childCount)。这个默认的策略，有办法调整吗？修改了之后，事件分发需要特殊处理吗？还是需要特殊处理?getChildAt会有相应变化吗? Q:通过ViewTreeObserver都可以监听什么回调?原理是什么? Q:你知道detachViewFromParent/attachViewToParent 这一组方法在哪些控件中被使用中？detachViewFromParent/attachViewToParent 与 removeView/addView 有什么区别呢？detachViewFromParent/attachViewToParent在什么场景下非常适合使用？ Q:requestLayout和invalidate的区别?都会执行到哪些生命周期? Q:ViewStub是什么?有什么应用场景?原理是什么? Q:系统可以在子线程中访问UI吗？为什么这样设计? Q:为什么Toast和showDialog可以在子线程显示?需要做些什么? Q:View.post为何可以获取宽高信息?   Q:View.getContext()一定会返回activity对象吗?    并不是,有这么几种情况:\n View.inflate的时候手动传的不是activity 当使用AppCompatActivity时,context是TintWrapContext  Q:View.inflate和LayoutInflater.inflate方法区别？    View.inflate是对LayoutInflater的封装,其内部就是调用的LayoutInflater.inflate 创建view的方法是LayoutInflater的createViewFromTag方法。会依次调用mFactory2、mFactory和mPrivateFactory三者之一的onCreateView方法去创建一个View。如果不存在Factory，则调用LayoutInflater自身的onCreateView或者createView来实例化View\nQ:Inflate的三个参数(int resource, ViewGroup root, boolean attachToRoot),组合设置后分别有什么效果?     如果root为null，attachToRoot将失去作用，则resource布局文件最外层设置任何值都没有意义，仅仅是解析布局文件的子View。 如果root不为null，attachToRoot设为true，则会给布局文件指定一个父布局，即root。（merge作为父布局标签为什么需要attachToRoot设为true的原因）,不需要调用addView 如果root不为null，attachToRoot设为false，则会将布局文件最外层的所有layout属性进行设置，当该view被添加到父view当中时，这些layout属性会自动生效。需要调用addView 在不设置attachToRoot参数的情况下，如果root不为null，attachToRoot参数默认为true；如果root为null，attachToRoot参数为false。  Q:子线程中可以更新UI吗?为什么?    可以,线程检查是在ViewRootImpl的checkThread()中。ViewRootImpl的初始化是在Activity的onResume()方法之后。因此，如果有子线程在onResume之前更新UI是可以成功的。当然还有一种Hook ViewRootImpl的mThread的方法也可以更新UI\nQ:View坐标体系是什么?    Q:为什么setTranslation会移动View的位置?    因为view的getX或者getY中会通过mTop + getTranslation来确定最终的X或者Y\nQ:为什么View移动的位置跟mScrollX，mScrollY是相反的?    因为view在draw的时候,会对mScrollX，mScrollY进行取反\nQ:都有什么获取view区域的方法?怎么用?    前置条件: View 长宽： width:600 height:200\nView 四个顶点： mLeft = -200 mTop = 200 mRight = 400 mBottom = 400;\n 子布局可以超过父布局展示 clipChildren=false  getLocationInWindow:View距离Window左上角坐标，因为View超出了Window，因此获取的坐标为[x,y]=[-100,400]\ngetLocationOnScreen:View距离屏幕左上角的坐标，在getLocationInWindow 基础上加上Window 的偏移。[x,y]=[-100, 400] + [200, 100] = [100, 500]\ngetGlobalVisibleRect:View的可见部分在Window里的区域，View的真实区域：白色 + 红色 部分，只是白色部分超出了Window，不会展示，可见区域是红色部分。rect=[0, 400, 500, 600] 左上右下\ngetLocalVisibleRect:View可见部分相对于自身的区域，也就是说自身的哪些区域可见。在getGlobalVisibleRect基础上，不断查找。rect=[100, 0, 600, 200]\ngetHitRect:获取View有效的点击区域，以四个顶点为基础，考虑matrix，得出结果如下：rect=[-200,200,400, 400]\ngetDrawingRect:获取View的绘制区域，以四个顶点为基础，考虑scroll值，得出结果如下：rect=[0,0,600,200]\n子布局不可以超过父布局展示 clipChildren=true  getGlobalVisibleRect:可以看出，红色部分为可见区域，那么该区域相对Window左上角的距离为：rect=[100,400,500,600]\ngetLocalVisibleRect:红色部分在View自身里的区域:rect=[200,0,600,200]\nQ:View的绘制流程分几步，从哪开始？哪个过程结束以后能看到view？    从ViewRoot的performTraversals开始，经过measure，layout,draw 三个流程。draw流程结束以后就可以在屏幕上看到view了。\nQ:View什么时候发生绘制?     由于onCreate会先于handleResumeActivity执行，我们在onCreate中调用了setContentView，也只是生成DecorView并给这个DecorView的内容设置了布局而已，此时还并没有把这个DecorView添加到Window中，同样，WMS中也还没有这个Window，所以此时并不能做任何事情（绘制、接收点击事件等），虽然调用了requestLayout和invalidate，并不会真正触发布局和重绘（因为还没有与ViewRootImpl进行绑定） Activity与Window产生联系，是在调用activity#attach方法中，生成了一个PhoneWindow，并把这个activity对象自身，设置给了Window的Callback回调（Activity实现了Window的Callback接口） Window与WindowManagerService产生联系，是在handleResumeActivity中，先执行了onResume方法，通过调用WindowManagerImpl#addView方法将这个Activity对应的DecorView添加到了这个Window中，addView方法是一个IPC操作，将这个Window也添加到了WindowManagerService中； ViewRootImpl与Window产生联系，是在WindowManagerImpl#addView方法中，这个过程中会new一个ViewRootImpl与DecorView相对应，保存在WindowManagerGloable中； 总的来说，就是setContentView生成了DecorView及其视图，在onResume之后才把这个视图添加进了Window和WMS中，具备了交互能力  Q:ViewGroup有onMeasure方法吗？为什么?    没有，这个方法是交给子类自己实现的。不同的viewgroup子类 肯定布局都不一样，那onMeasure索性就全部交给他们自己实现好了\nQ:setContentView之后发生了什么？    Q:setContentView可以在其他生命周期内执行吗?为什么?    可以,因为Activity.setContentView只是api。实际操作是去交给了PhoneWindow去做的，可以在onContentChanged中进行Activity View成员变量的初始化操作(findViewById等)。因为setContentView是同步操作，所以直接在setContentView之后findViewById也没什么问题\nQ:view、drawable、bitmap之间的关系?    bitmap： 仅仅就是一个位图 你可以理解为一张图片在内存中的映射。 就这么简单。这个很多人都知道\nview： view最大的作用是2个 一个是draw 也就是canvas的draw方法，还有一个作用 就是测量大小。\ndrawable： 他其实本身和bitmap没有关系, 你可以把他理解为是一个绘制工具，和view的第一个作用是一摸一样的，你能用view的canvas 画出来的东西 你用drawable 一样可以画出来， 不一样的是drawable 仅仅能绘制，但是不能测量自己的大小，但是view可以。 换句话说 drawable 承担了view的一半作用\nQ:有了view，为什么还要设计drawable?    假设你要自定义 一组view，注意是一组，不是一个， 那你就可以把这一组view中 共同的部分 抽成一个drawable ，这样view就可以复用 这个drawble了，不用写重复的 canvas.draw 方法\nQ:如何设计一个曝光系统?需要注意些什么?     要确定什么样的算有效曝光（在屏幕停留时间超过一个值如2秒）可以通过attachToWindow、detachToWindow记录时间 监听到每个view移入和移出屏幕的事件 View.getLoaclRect  Q:有用过LayoutInflater.Factory吗？都有哪些应用场景?    系统通过Factory提供了一种hook的方法，方便开发者拦截LayoutInflater创建View的过程。应用场景包括\n 在XML布局中自定义标签名称； 全局替换系统控件为自定义View； 替换app中字体； 全局换肤  Q:SurfaceView是什么?有哪些应用场景?    Q:一个viewGroup 绘制了4-5个view，当其中一个子view。例如背景变了。就会导致整个viewGroup的刷新。。请问有没有办法？仅仅只让对应的view更改UI。避免让viewGroup重新测量 绘制?    调用view的invalidate方法，执行view的重新绘制\nQ:在绘制阶段，ViewGroup 不光要绘制自身，还需循环绘制其一众子 View，这个绘制策略默认为顺序绘制，即 [0 ~ childCount)。这个默认的策略，有办法调整吗？修改了之后，事件分发需要特殊处理吗？还是需要特殊处理?getChildAt会有相应变化吗?    可以调整,\n 通过setChildrenDrawingOrderEnabled(true)来开启自定义顺序； 重写getChildDrawingOrder方法来决定什么时候要返回哪个子View； 其中RecyclerView还可以通过一个setChildDrawingOrderCallback方法来动态指定顺序，而不用重写RecyclerView  自定义DrawingOrder，只是改变事件分发和子View绘制的顺序，ViewGroup内部mChildren数组的排序是不会变的，所以不要认为通过修改DrawingOrder也能同时改变getChildAt方法返回的View对象。\nQ:通过ViewTreeObserver都可以监听什么回调?原理是什么?    视图即将绘制,视图布局发生变化,原理就是时间发生时会系统发出回调\nQ:你知道detachViewFromParent/attachViewToParent 这一组方法在哪些控件中被使用中？detachViewFromParent/attachViewToParent 与 removeView/addView 有什么区别呢？detachViewFromParent/attachViewToParent在什么场景下非常适合使用？    addView和removeView方法，操作容器内的子视图数组，触发视图重绘制，触发子视图attach和detached窗体回调。 addViewInLayout和removeViewInLayou方法，与上面一样，只是不会重绘视图。 attachViewToParent和detachViewFromParent方法，只会操作容器内的子视图数组,recyclerview中\nQ:requestLayout和invalidate的区别?都会执行到哪些生命周期?     调用requestlayout，会导致自己的View设置两个标志位，并且向上调用父类的requestlayout并且设置标志位，不断向上传递，最后上传到ViewRootImp执行performTraversals执行measure,layout(在三大流程中检查标志位)（不一定执行onDraw,没有设置PFLAG_DIRTY_MASK标志位） 调用Invalidate方法给该View设置PFLAG_DIRTY标志位，然后不断计算在父容器中的区域向上传递(设置标志位)，最终传递到RootViewImp执行scheduleTraversals然后执行performTraversals，然后measure,layout,draw三个方法，由于没有设置PFLAG_FORCE_LAYOUT标志位，只能执行draw方法，前面两个不执行(不是不执行，只是不执行特有的方法)  Q:ViewStub是什么?有什么应用场景?原理是什么?    ViewStub是一个不可见的，宽高为0的View，可用于在程序运行的时候延迟 加载布局资源的（用于实现布局资源的“懒加载”),当使ViewStub可见或者调用inflate方法，可以使布局资源被加载！ 初始化时setWillNotDraw(true),onMeasure时设置宽高为0，onDraw中不进行任何绘制\n inflateViewNoAdd：获取到布局渲染器将真正需要展示的布局文件渲染成View并且给返回。 replaceSelfWithView：将ViewStub从布局文件结构中移除，同时把渲染好的View添加到ViewStub之前所处的位置 之后把渲染好的View的弱引用给存储起来。方便在setVisibility()方法中使用。  Q:系统可以在子线程中访问UI吗？为什么这样设计?    不可以,这样设计是因为Android的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态,UI不搞成加锁的是因为 ①首先加上锁机制会让UI访问的逻辑变得复杂\n②锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。 所以最简单且高效的方法就是采用单线程模型来处理UI操作。\nQ:为什么Toast和showDialog可以在子线程显示?需要做些什么?    Toast\\Dialog本质是通过window显示和绘制的（操作的是window），而主线程不能更新UI 是因为ViewRootImpl的checkThread方法在Activity维护的View树的行为 Toast中TN类使用Handler是为了用队列和时间控制排队显示Toast,所以需要Looper.prepare和Looper.loop\nQ:View.post为何可以获取宽高信息?    如果在 performTraversals 前调用 View.post，则会将消息进行保存，之后在 dispatchAttachedToWindow 的时候通过 ViewRootImpl 中的 Handler 进行调用。 如果在 performTraversals 以后调用 View.post，则直接通过 ViewRootImpl 中的 Handler 进行调用。\n"},{"id":12,"href":"/","title":"十万个为什么","parent":"","content":""},{"id":13,"href":"/interview/android/%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/","title":"图形系统","parent":"Android","content":"  Q:SurfaceFlinger是什么?有什么用? Q:什么是Surface? Q:Choreographer是什么?有什么用? Q:Choreographer是如何控制实现在下一个Vsync信号到来时实现View绘制的? Q:ViewRootImpl是如何实现从scheduleTraversals到performTraversals的? Q:ChoreoGrapher在初始化的时候,都做了什么? Q:一些QA Q:HWC是什么?有什么用? Q:Vsync信号是什么? Q:客户端是如何请求Vsync信号的?是合适触发的? Q:说说Android的多重缓冲?   Q:SurfaceFlinger是什么?有什么用?    SurfaceFlinger负责合成所有的Layer并送显到Display,在Android系统中,SurfaceFlinger是一个独立进程\nQ:什么是Surface?    Surface是一个窗口，例如：一个Activity是一个Surface、一个Dialog也是一个Surface，承载了上层的图形数据，与SurfaceFlinger侧的Layer相对应\nQ:Choreographer是什么?有什么用?    在收到VSync pulse后，将马上开始下一帧的渲染。即一旦收到VSync通知，CPU和GPU就立刻开始计算然后把数据写入buffer。而这一\u0026quot;drawing with VSync\u0026quot; 的实现就是Choreographer\nQ:Choreographer是如何控制实现在下一个Vsync信号到来时实现View绘制的?     所有UI的变化都是走到ViewRootImpl的scheduleTraversals()方法。 在VSync信号到来时才会执行绘制，即ViewRootImpl.performTraversals()  Q:ViewRootImpl是如何实现从scheduleTraversals到performTraversals的?     首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。 然后把当前线程的消息队列Queue添加了同步屏障，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。 调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即在下一个VSync到来时会执行TraversalRunnable\u0026ndash;\u0026gt;doTraversal()\u0026mdash;\u0026gt;performTraversals()\u0026ndash;\u0026gt;绘制流程。  Q:ChoreoGrapher在初始化的时候,都做了什么?     创建了一个mHandler,FrameHandler:传入当前线程Looper,用来分发每一帧事件,主要有三种:有延迟的任务发延迟消息、不在原线程的发到原线程、没开启VSYNC的直接走 doFrame 方法取执行绘制 VSync事件接收器mDisplayEventReceiver,继承runnable:在onVsync回调中将本身将接收器本身作为runnable传入异步消息msg，并使用mHandler发送msg，最终执行的就是doFrame()方法了,这里因为是使用handler发送消息到MessageQueue中，不一定是立刻执行，如何MessageQueue中前面有较为耗时的操作，那么就要等完成，才会执行本次的doFrame() 任务链表数组mCallbackQueues:建一个链表类型CallbackQueue的数组，大小为5，也就是数组中有五个链表，每个链表存相同类型的任务,按照处理优先级依次为：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）  Q:一些QA     丢帧(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 答：延迟显示，因为缓存交换的时机只能等下一个VSync了。 布局层级较多/主线程耗时 是如何造成 丢帧的呢？ 答：布局层级较多/主线程耗时 会影响CPU/GPU的执行时间，大于16.6ms时只能等下一个VSync了。 16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure/layout/draw ？ 答：屏幕的固定刷新频率是60Hz，即16.6ms。不是每16.6ms都走一次 measure/layout/draw，而是有绘制任务才会走，并且绘制时间间隔是取决于布局复杂度及主线程耗时。 measure/layout/draw 走完，界面就立刻刷新了吗? 答：不是。measure/layout/draw 走完后 会在VSync到来时进行缓存交换和刷新。 如果界面没动静止了，还会刷新吗？ 答：屏幕会固定没16.6ms刷新，但CPU/GPU不走绘制流程。见下面的SysTrace图。 可能你知道VSYNC，这个具体指啥？在屏幕刷新中如何工作的？ 答：当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时会出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。并且Android4.1后 CPU/GPU的绘制是在VSYNC到来时开始。 可能你还听过屏幕刷新使用 双缓存、三缓存，这又是啥意思呢？ 答：双缓存是Back buffer、Frame buffer，用于解决画面撕裂。三缓存增加一个Back buffer，用于减少Jank。 可能你还听过神秘的Choreographer，这又是干啥的？ 答：用于实现——\u0026ldquo;CPU/GPU的绘制是在VSYNC到来时开始\u0026rdquo;  Q:HWC是什么?有什么用?    HWC（hwcomposer）是Android中进行窗口（Layer）合成和显示的HAL层模块，其实现是特定于设备的，而且通常由显示设备制造商 (OEM)完成，为SurfaceFlinger服务提供硬件支持\nQ:Vsync信号是什么?    VSync信号是由HWC硬件模块根据屏幕刷新率产生\nQ:客户端是如何请求Vsync信号的?是合适触发的?     当View.invalidate调用后，最终会触发ViewRootImpl向Choreographer注册一个TraversalRunnable。 Choreographer本地保存这个TraversalRunnable后，会通过DisplayEventReceiver.java调用到Native层，最终一步步调用到mEventThread线程，修改connection-\u0026gt;count = 0(请求接收下一次VSync)。 Vsync到来后，会从SurfaceFlinger进程一步步回调到客户端进程，最终触发ViewRootImpl之前注册TraversalRunnable，启动View树的渲染。  Q:说说Android的多重缓冲?    双缓存的交换 是在Vsyn到来时进行，交换后屏幕会取Frame buffer内的新数据，而实际 此时的Back buffer 就可以供GPU准备下一帧数据了。 如果 Vsyn到来时 CPU/GPU就开始操作的话，是有完整的16.6ms的，这样应该会基本避免jank的出现了,Google在Android 4.1系统中对Android Display系统进行了重构，实现了Project Butter（黄油工程）：系统在收到VSync pulse后，将马上开始下一帧的渲染。即一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer\n"},{"id":14,"href":"/interview/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"多线程","parent":"Java","content":"  Q:什么是ThreadLocal?是如何实现的? Q:ThreadLocal造成内存泄漏的原因?如何解决? Q:如何保证线程的处理是安全的? Q:JAVA中的锁有哪些处理方式？ Q:java虚拟机中对象头的锁结构是什么样的? Q:synchroinized是如何进行锁升级的? Q:线程的生命周期? Q:启动一个thread有哪几种方法?有什么区别? Q:yield和sleep有什么异同? Q:interrupted在阻塞态跟非阻塞态不同表现? Q:为什么不建议使用stop停止线程? Q:多线程三要素? Q:synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？ Q:造成死锁的原因? Q:voliate原理? Q:CAS是什么?有什么问题？ Q:线程池原理?有几种运行状态? Q:Worker 的实现类，为什么不使用 ReentrantLock 来实现呢，而是自己继承AQS? Q:AQS锁有哪些?各有什么特点? Q:公平锁是如何实现的? Q:CountDownLactch与CyclicBarrier区别? Q:Java中锁的类型? Q:锁优化都有哪些?   Q:什么是ThreadLocal?是如何实现的?    线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域 ThreadLocal的数据结构\n//threadLocalHashCode的值是HASH_INCREMENT = 0x61c88647每次+1,取0x61c88647是因为这个值是黄金分割点 //每个线程有唯一的一个ThreadLocalMap,每个ThreadLocalMap中可以存放多个ThreadLocal对象 ThreadLocalMap(ThreadLocal firstKey, Object firstValue) { table = new Entry[INITIAL_CAPACITY]; //table是一个弱引用对象数组  //INITIAL_CAPACITY=16  int i = firstKey.threadLocalHashCode \u0026amp; (INITIAL_CAPACITY - 1);//有hash证明这是个采用哈希散列方式进行存储  table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);//设置扩容因子为len * 2 / 3 } cleanSomeSlots:启发式清理,试探的扫描一些单元格，寻找过期元素，也就是被垃圾回收的元素 expungeStaleEntry:探测式清理,是以当前遇到的 GC 元素开始，向后不断的清理。直到遇到 null 为止，才停止 rehash 计算\nQ:ThreadLocal造成内存泄漏的原因?如何解决?    若堆中ThreadLocal对象会被gc回收，Entry的key为null，但是value不为null，且value也是强引用（连线6），所以Entry仍旧不能回收，只能释放ThreadLocal的内存，仍旧可能导致内存泄漏。在没有自动清理陈旧Entry的前提下，即使Entry使用弱引用，仍可能出现内存泄漏。 在threadlocal进行set、get、remove时都会进行内存回收操作,这样就避免了内存泄漏\nQ:如何保证线程的处理是安全的?    线程同步,使用synchroinized或者ReentrantLock\nQ:JAVA中的锁有哪些处理方式？    Q:java虚拟机中对象头的锁结构是什么样的?    Q:synchroinized是如何进行锁升级的?    Q:线程的生命周期?    Q:启动一个thread有哪几种方法?有什么区别?     实现Runnable接口,支持多继承 实现Callable接口,支持多继承,支持获取线程返回值 继承Thread类  Q:yield和sleep有什么异同?    两者都不会释放锁,yield只会使同优先级或者更高优先级的线程得到执行机会\nQ:interrupted在阻塞态跟非阻塞态不同表现?    阻塞态:抛出InterruptedException,同时调用interrupte方法,此时isInterrupted返回true,然后被重置为false 非阻塞态:会调用interrupted方法\nQ:为什么不建议使用stop停止线程?    thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性\nQ:多线程三要素?     原子性（Atomicity）：单个或多个操作是要么全部执行，要么都不执行  Lock：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁的代码 synchronized：对线程加独占锁，被它修饰的类/方法/变量只允许一个线程访问   可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改  volatile：保证新值能立即同步到主内存，且每次使用前立即从主内存刷新； synchronized：在释放锁之前会将工作内存新值更新到主存中   有序性（Ordering）：程序代码按照指令顺序执行  volatile： 本身就包含了禁止指令重排序的语义 synchronized：保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入    Q:synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？     使用this修饰代码块，同步的同一个对象对代码块的多线程访问 修饰非静态方法,同步的是同一个对象对这个方法的多线程访问 修饰静态方法,同步的是这个类所有对象对这个方法的多线程访问  Q:造成死锁的原因?     互斥条件：一个资源每次只能被一个线程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。  Q:voliate原理?    如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存\n Lock前缀的指令会引起处理器缓存写回内存； 一个处理器的缓存回写到内存会导致其他处理器的缓存失效； 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。  Q:CAS是什么?有什么问题？    CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。 CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作\n 循环时间长开销很大。 只能保证一个共享变量的原子操作。 ABA问题。使用AtomicStampedReference  Q:线程池原理?有几种运行状态?     RUNNING：运行状态，接受新的任务并且处理队列中的任务。 SHUTDOWN：关闭状态(调用了shutdown方法)。不接受新任务，,但是要处理队列中的任务。 STOP：停止状态(调用了shutdownNow方法)。不接受新任务，也不处理队列中的任务，并且要中断正在处理的任务。 TIDYING：所有的任务都已终止了，workerCount为0，线程池进入该状态后会调 terminated() 方法进入TERMINATED 状态。 TERMINATED：终止状态，terminated() 方法调用结束后的状态。  Q:Worker 的实现类，为什么不使用 ReentrantLock 来实现呢，而是自己继承AQS?    tryAcquire方法它是不允许重入的，而ReentrantLock是允许重入的。对于线程来说，如果线程正在执行是不允许其它锁重入进来的。 线程只需要两个状态，一个是独占锁，表明正在执行任务；一个是不加锁，表明是空闲状态。\nQ:AQS锁有哪些?各有什么特点?    AQS:AbstractQueuedSynchronizer,队列同步器\n ReentrantReadWriteLock 读写锁,读锁是共享锁、写锁是独占锁 ReentrantLock 可重入锁 CountDownLatch 闭锁 Semaphore 信号量锁,主要用于控制流量 ,new Semaphore(2, false);  Q:公平锁是如何实现的?    Q:CountDownLactch与CyclicBarrier区别?    CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用\nQ:Java中锁的类型?     可重入锁:可重入锁又名递归锁，直指同一个线程在外层方法获得锁之后，在进入内层方法时，会自动获得锁。可重入锁的好处之一就是在一定程度上避免死锁  Q:锁优化都有哪些?     自旋锁:自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态,但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景 锁消除:是指对于被检测出不可能存在竞争的共享数据的锁进行消除。 锁粗化:如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部 轻量级锁:轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销  "},{"id":15,"href":"/interview/java/%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"字符串","parent":"Java","content":"  Q:字符编码 Q:Stirng不可变原因? Q:为什么要设计为不可变? Q:字符编码?   Q:字符编码     GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节； UTF-16be 编码中，中文字符和英文字符都占 2 个字节  Q:Stirng不可变原因?     String主要的三个成员变量 char value[]， int offset, int count均是private，final的，并且没有对应的 getter/setter; String 对象一旦初始化完成，上述三个成员变量就不可修改；并且其所提供的接口任何对这些域的修改都将返回一个新对象； 技术博客大总结 是典型的 Immutable 类，被声明成为 final class，所有属性也都是final的。也由于它的不可变，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。  Q:为什么要设计为不可变?     可以缓存 hash 值 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 String Pool 的需要 如果一个String对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 安全性 String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。 线程安全 String 不可变性天生具备线程安全，可以在多个线程中安全地使用。  Q:字符编码?     ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。 UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。 Unicode 编码中，一个英文为一个字节，一个中文为两个字节。 符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 . 占1个字节的大小，中文句号 。占2个字节的大小。 UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode 扩展区的一些汉字存储需要 4 个字节）。 UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。  "},{"id":16,"href":"/interview/java/%E5%BC%82%E5%B8%B8/","title":"异常","parent":"Java","content":"  Q:被检查的异常和不受检查的异常有什么区别? Q:异常处理的原理？ Q:try-finally-return执行顺序?   Q:被检查的异常和不受检查的异常有什么区别?     受检查异常  被检查的异常应该用try-catch块代码处理，或者在main方法中用throws关键字让JRE了解程序可能抛出哪些异常。 Exception是所有被检查异常的基类 被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的FileNotFoundException   不受检查异常  不受检查的异常在程序中不要求被处理或用throws语句告知。 RuntimeException是所有不受检查异常的基类。 不被检查的异常通常都是由于糟糕的编程引起的，比如：在对象引用时没有确保对象非空而引起的NullPointerException    Q:异常处理的原理？    Java虚拟机用方法调用栈（method invocation stack）来跟踪每个线程中一系列的方法调用过程。如果在执行方法过程中抛出异常，则Java虚拟机必须找到能捕获该异常的catch代码块。当Java虚拟机追溯到调用栈的底部的方法的时候，如果仍然没有找到处理该异常的代码块，这样它就会按步骤处理，首先会打印方法调用栈的异常信息，然后如果所处的线程不是主线程，那么就会终止这个线程\nQ:try-finally-return执行顺序?    public class TestReturn { public int test(){ int x = 1; try{ return ++x; } catch(Exception e){ }finally{ return ++x; } //return x;  } public static void main(String[] args){ TestReturn t = new TestReturn(); int result = t.test(); System.out.println(result);//2  } }  遇到return语句时会在局部变量区额外分配一块空间存储值,待代码执行完毕会直接返回这个值 如果finally中有return的话,会以finally中的return为准  "},{"id":17,"href":"/interview/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","title":"性能优化","parent":"Android","content":"  Q:常用内存命令有哪些? Q:启动优化?   Q:常用内存命令有哪些?     USS\tUnique Set Size\t物理内存\t进程独占的内存 PSS\tProportional Set Size\t物理内存\tPSS= USS+ 按比例包含共享库 RSS\tResident Set Size\t物理内存\tRSS= USS+ 包含共享库 VSS\tVirtual Set Size\t虚拟内存\tVSS= RSS+ 未分配实际物理内存   dumpsys meminfo //dumpsys meminfo \u0026ndash;package // 输出指定包名的进程，可能包含多个进程 适用场景： 查看进程的oom adj，或者dalvik/native等区域内存情况，或者某个进程或apk的内存情况，功能非常强大； procrank //适用场景： 查看进程的VSS/RSS/PSS/USS各个内存指标； cat /proc/meminfo //适用场景： 查看系统的详尽内存信息，包含内核情况； free //适用场景： 只查看系统的可用内存； showmap //适用场景： 查看进程的虚拟地址空间的内存分配情况； vmstat //适用场景： 周期性地打印出进程运行队列、系统切换、CPU时间占比等情况  Q:启动优化?     attachBaseContext Application attach installContentProviders Application onCreate Looper.loop Activity onCreate，onResume  "},{"id":18,"href":"/interview/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/","title":"数组","parent":"算法","content":"  有序数组索引  Q:从排序数组中找到目标值并返回其索引   原地删除元素  Q:给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度?   最小子串  Q:给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0     有序数组索引    Q:从排序数组中找到目标值并返回其索引     输入: [1,3,5,6], 5 输出: 2   关键点:\n 有序数组 边界处理   int searchInsert1(int[] nums, int target) { int n = nums.length(); int left = 0; int right = n - 1; // 定义target在左闭右闭的区间里，[left, right]  while (left \u0026lt;= right) { // 当left==right，区间[left, right]依然有效  int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2  if (nums[middle] \u0026gt; target) { right = middle - 1; // target 在左区间，所以[left, middle - 1]  } else if (nums[middle] \u0026lt; target) { left = middle + 1; // target 在右区间，所以[middle + 1, right]  } else { // nums[middle] == target  return middle; } } // 分别处理如下四种情况  // 目标值在数组所有元素之前 [0, -1]  // 目标值等于数组中某一个元素 return middle;  // 目标值插入数组中的位置 [left, right]，return right + 1  // 目标值在数组所有元素之后的情况 [left, right]， return right + 1  return right + 1; int searchInsert2(int[] nums, int target) { int n = nums.length(); int left = 0; int right = n; // 定义target在左闭右开的区间里，[left, right) target  while (left \u0026lt; right) { // 因为left == right的时候，在[left, right)是无效的空间  int middle = left + ((right - left) \u0026gt;\u0026gt; 1); if (nums[middle] \u0026gt; target) { right = middle; // target 在左区间，在[left, middle)中  } else if (nums[middle] \u0026lt; target) { left = middle + 1; // target 在右区间，在 [middle+1, right)中  } else { // nums[middle] == target  return middle; // 数组中找到目标值的情况，直接返回下标  } } // 分别处理如下四种情况  // 目标值在数组所有元素之前 [0,0)  // 目标值等于数组中某一个元素 return middle  // 目标值插入数组中的位置 [left, right) ，return right 即可  // 目标值在数组所有元素之后的情况 [left, right)，return right 即可  return right; } 原地删除元素    Q:给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度?    给定 nums = [3,2,2,3], val = 3 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2   关键点:\n 快慢指针   int removeElement(int[] nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex \u0026lt; nums.length(); fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } 最小子串    Q:给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0    输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。   关键点:\n 滑动窗口:所谓滑动窗口，「就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果」   int minSubArrayLen(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = INT32_MAX; int sum = 0; // 滑动窗口数值之和  int i = 0; // 滑动窗口起始位置  int subLength = 0; // 滑动窗口的长度  for (int j = 0; j \u0026lt; nums.size(); j++) { sum += nums[j]; // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件  while (sum \u0026gt;= s) { subLength = (j - i + 1); // 取子序列的长度  result = result \u0026lt; subLength ? result : subLength; sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）  } } // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列  return result == INT32_MAX ? 0 : result; } "},{"id":19,"href":"/interview/android/%E6%B3%A8%E8%A7%A3/","title":"注解","parent":"Android","content":"  Q:Android中提供了哪些与线程相关的注解? Q:抽象处理器中四个方法有何作用？annotationProcessor和apt区别？   Q:Android中提供了哪些与线程相关的注解?     @UiThread,通常可以等同于主线程,标注方法需要在UIThread执行,比如View类就使用这个注解 @MainThread 主线程,经常启动后创建的第一个线程 @WorkerThread 工作者线程,一般为一些后台的线程,比如AsyncTask里面的doInBackground就是这样的 @BinderThread 注解方法必须要在BinderThread线程中执行,一般使用较少  Q:抽象处理器中四个方法有何作用？annotationProcessor和apt区别？      抽象处理器中四个方法有何作用\n init(ProcessingEnvironment processingEnvironment): 每一个注解处理器类都必须有一个空的构造函数。然而，这里有一个特殊的init()方法，它会被注解处理工具调用，并输入ProcessingEnviroment参数。ProcessingEnviroment提供很多有用的工具类Elements,Types和Filer。后面我们将看到详细的内容。 process(Set\u0026lt;? extends TypeElement\u0026gt; set, RoundEnvironment roundEnvironment): 这相当于每个处理器的主函数main()。你在这里写你的扫描、评估和处理注解的代码，以及生成Java文件。输入参数RoundEnviroment，可以让你查询出包含特定注解的被注解元素。后面我们将看到详细的内容。 getSupportedAnnotationTypes(): 这里你必须指定，这个注解处理器是注册给哪个注解的。注意，它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。换句话说，你在这里定义你的注解处理器注册到哪些注解上。 getSupportedSourceVersion(): 用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()。然而，如果你有足够的理由只支持Java 7的话，你也可以返回SourceVersion.RELEASE_7    annotationProcessor和apt区别？\n Android 官方的 annotationProcessor 同时支持 javac 和 jack 编译方式，而 android-apt 只支持 javac 方式。当然，目前 android-apt 在 Android Gradle 插件 2.2 版本上面仍然可以正常运行，如果你没有想支持 jack 编译方式的话，可以继续使用 android-apt。    Q:自定义注解又是怎么分类的？运行期注解原理是什么？     @Retention 定义：  @Retention(RetentionPolicy.SOURCE)  源码时注解，一般用来作为编译器标记。如Override, Deprecated, SuppressWarnings。   @Retention(RetentionPolicy.RUNTIME)  运行时注解，在运行时通过反射去识别的注解。 定义运行时注解，只需要在声明注解时指定@Retention(RetentionPolicy.RUNTIME)即可。 运行时注解一般和反射机制配合使用，相比编译时注解性能比较低，但灵活性好，实现起来比较简答。   @Retention(RetentionPolicy.CLASS)  编译时注解，在编译时被识别并处理的注解。 编译时注解能够自动处理Java源文件并生成更多的源码、配置文件、脚本或其他可能想要生成的东西。     @Target 定义:用来修饰哪些程序元素  @Target(METHOD)  用于描述方法 \u0026hellip;      Q:什么是依赖注入?有哪些方式可以实现依赖注入?     依赖注入就是将A的对象传入到B的对象内部使用 三种实现方式:  构造器注入  将需要的依赖作为构造方法的参数传递完成依赖注入。   Setter方法注入  增加setter方法，参数为需要注入的依赖亦可完成依赖注入   接口注入  接口注入，闻其名不言而喻，就是为依赖注入创建一套接口，依赖作为参数传入，通过调用统一的接口完成对具体实现的依赖注入。 接口注入和setter方法注入类似，不同的是接口注入使用了统一的方法来完成注入，而setter方法注入的方法名称相对比较随意。      "},{"id":20,"href":"/interview/android/%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1/","title":"消息通信","parent":"Android","content":"  Q:Linux都有哪些进程间通信方式（IPC）？Android呢? Q:什么是Binder?为什么使用Binder作为Android IPC？ Q:什么是mmap? Q:为什么有共享内存了还需要设计Binder? Q:ServiceManager启动流程? Q:Binder线程池大小? Q:Binder创建的内核内存大小? Q:Binder进程与线程? Q:如果有多个进程向用一个Server服务发出Binder请求处理?会发生什么? Q:Binder是如何进行权限控制的? Q:什么情况下会触发Binder的linkToDeath?如何触发? Q:Android中哪些IPC用到了Socket,为什么? Q:Handler是什么? Q:Handler机制主要包含什么?各自用途是什么? Q:Looper.prepare可以多次调用吗?为什么? Q:Handler中消息分发顺序? Q:用过Message的setAsynchronous吗?有什么用? Q:Looper 死循环为什么不会导致应用卡死，会消耗大量资源吗？ Q:主线程的Handler是在ActivityThread中启动的,那么他是一个线程吗?不是的话,那么主线程所依附的线程是什么? Q:为什么handler会造成内存泄漏?如何处理? Q:handler的postDelay是如何实现的?   Q:Linux都有哪些进程间通信方式（IPC）？Android呢?    Linux:\n 管道：在创建时分配一个page大小的内存，缓存区大小比较有限； 消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信； 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决； 套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信； 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等； Android: Binder Socket Handler  Q:什么是Binder?为什么使用Binder作为Android IPC？     使用mmap只拷贝一次内存使Binder变的高效  binder_mmap通过加锁，保证一次只有一个进程分配内存，保证多进程间的并发访问。 虚拟进程地址空间(vm_area_struct)和虚拟内核地址空间(vm_struct)都映射到同一块物理内存空间。当Client端与Server端发送数据时，Client（作为数据发送端）先从自己的进程空间把IPC通信数据copy_from_user拷贝到内核空间，而Server端（作为数据接收端）与内核共享数据，不再需要拷贝数据，而是通过内存地址空间的偏移量，即可获悉内存地址，整个过程只发生一次内存拷贝  Q:什么是mmap?    mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系\nQ:为什么有共享内存了还需要设计Binder?    共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，Binder架构优越于共享内存\nQ:ServiceManager启动流程?     打开binder驱动，并调用mmap()方法分配128k的内存映射空间：binder_open(); 通知binder驱动使其成为守护进程：binder_become_context_manager()； 验证selinux权限，判断进程是否有权注册或查看指定服务； 进入循环状态，等待Client端的请求：binder_loop()。 注册服务的过程，根据服务名称，但同一个服务已注册，重新注册前会先移除之前的注册信息； 死亡通知: 当binder所在进程死亡后,会调用binder_release方法,然后调用binder_node_release.这个过程便会发出死亡通知的回调.  Q:Binder线程池大小?    Binder线程创建与其所在进程的创建中产生,默认地，每个进程的binder线程池的线程个数上限为15,创建的binder线程个数上限为8\nQ:Binder创建的内核内存大小?    1M-8k,8K是为了内存优化\nQ:Binder进程与线程?     Binder进程:对于底层Binder驱动，通过binder_procs链表记录所有创建的binder_proc结构体，binder驱动层的每一个binder_proc结构体都与用户空间的一个用于binder通信的进程一一对应，且每个进程有且只有一个ProcessState对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程,在每个进程中可以有很多个线程，每个线程对应一个IPCThreadState对象，IPCThreadState对象也是单例模式，即一个线程对应一个IPCThreadState对象\\n Binder线程:每个Server进程在启动时会创建一个binder线程池，并向其中注册一个Binder线程；之后Server进程也可以向binder线程池注册新的线程，或者Binder驱动在探测到没有空闲binder线程时会主动向Server进程注册新的的binder线程。对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程  Q:如果有多个进程向用一个Server服务发出Binder请求处理?会发生什么?    每个接收端进程都有一个todo队列，用于保存发送端进程发送过来的binder请求，这类请求可以由接收端进程的任意一个空闲的binder线程处理；接收端进程存在一个或多个binder线程，在每个binder线程里都有一个todo队列，也是用于保存发送端进程发送过来的binder请求，这类请求只能由当前binder线程来处理\nQ:Binder是如何进行权限控制的?    //作用是清空远程调用端的uid和pid，用当前本地进程的uid和pid替代；返回值是远程调用端的uid和pid public static final native long clearCallingIdentity(); //作用是恢复远程调用端的uid和pid信息，正好是`clearCallingIdentity`的反过程; public static final native void restoreCallingIdentity(long token); Q:什么情况下会触发Binder的linkToDeath?如何触发?    Q:Android中哪些IPC用到了Socket,为什么?     zygote：用于孵化进程，system_server创建进程是通过socket向zygote进程发起请求； installd：用于安装App的守护进程，上层PackageManagerService很多实现最终都是交给它来完成； lmkd：lowmemorykiller的守护进程，Java层的LowMemoryKiller最终都是由lmkd来完成； adbd：这个也不用说，用于服务adb； logcatd:这个不用说，用于服务logcat； vold：即volume Daemon，是存储类的守护进程，用于负责如USB、Sdcard等存储设备的事件处理。  Q:Handler是什么?    Binder/Socket用于进程间通信，而Handler消息机制用于同进程的线程间通信，Handler消息机制是由一组MessageQueue、Message、Looper、Handler共同组成的，为了方便且称之为Handler消息机制\nQ:Handler机制主要包含什么?各自用途是什么?     Message：消息分为硬件产生的消息(如按钮、触摸)和软件生成的消息；Message中有一个用于处理消息的Handler；msg.target MessageQueue：消息队列的主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next)；MessageQueue有一组待处理的Message； Handler：消息辅助类，主要功能向消息池发送各种消息事件(Handler.sendMessage)和处理相应消息事件(Handler.handleMessage)；Handler中有Looper和MessageQueue。 Looper：不断循环执行(Looper.loop)，按分发机制将消息分发给目标处理者。Looper有一个MessageQueue消息队列；  Q:Looper.prepare可以多次调用吗?为什么?    不可以,在Looper.prepare中会创建MessageQueue对象,一个线程只能有一个MessageQueue队列\nprivate static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\u0026#34;Only one Looper may be created per thread\u0026#34;); } sThreadLocal.set(new Looper(quitAllowed)); } private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } Q:Handler中消息分发顺序?    if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } Message.callback.run \u0026gt; handler.callback.handleMessage \u0026gt; handleMessage\nQ:用过Message的setAsynchronous吗?有什么用?    同步屏障机制,提高消息的优先级,hide方法\nQ:Looper 死循环为什么不会导致应用卡死，会消耗大量资源吗？    空的死循环并不会导致应用卡死,导致应用卡死的是在循环里面做的事情 不会消耗大量资源,在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。\nQ:主线程的Handler是在ActivityThread中启动的,那么他是一个线程吗?不是的话,那么主线程所依附的线程是什么?    ActivityThread不是一个线程,他并不继承Thread类 进程与线程在Linux层面的区别就是是否可以共享资源,所以ActivityThread所依附的线程或者进程可以理解为通过zygote进程fork出来的应用进程\nQ:为什么handler会造成内存泄漏?如何处理?    如果向handler中发送一个延时消息,那么在activity销毁时,消息就会一直存在与looper的死循环中 如何处理:1.在activity销毁时调用removeMessage 2.将handler改为静态的\nQ:handler的postDelay是如何实现的?    在enqueueMessage时回去根据when决定将when=0的消息插入到头部\n"},{"id":21,"href":"/interview/%E7%AE%97%E6%B3%95/","title":"算法","parent":"Interviews","content":""},{"id":22,"href":"/interview/%E7%BD%91%E7%BB%9C/","title":"网络","parent":"Interviews","content":""},{"id":23,"href":"/interview/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/","title":"网络","parent":"网络","content":"  Q:GET 和 POST 的区别，你知道哪些？ Q:一个TCP连接可以对应几个HTTP请求？ Q:在浏览器中输入url地址后显示主页的过程? Q:DNS解析过程? Q:HTTP中有个缓存机制，但如何保证缓存是最新的呢？ Q:三次握手过程中可以携带数据吗？ Q:挥手为什么需要四次? Q:非对称密钥加密你了解吗？优缺点？ Q:HTTPS采用的加密方式有哪些？是对称还是非对称？ Q:TCP四大拥塞控制算法总结？（极其重要）  慢热启动算法 – Slow Start 拥塞避免算法 – Congestion Avoidance 拥塞发生状态时的算法 快速恢复算法 – Fast Recovery   Q:你了解流量控制原理吗？ Q:TCP 协议如何保证可靠传输？ Q:TCP 利用滑动窗口实现流量控制的机制？ Q:常见的HTTP状态码有哪些？  1xx 信息 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误     Q:GET 和 POST 的区别，你知道哪些？     get是获取数据，post是修改数据 get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以\u0026amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body） get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。 GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 GET请求会被浏览器主动缓存，而POST不会，除非手动设置。  Q:一个TCP连接可以对应几个HTTP请求？    如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的\nQ:在浏览器中输入url地址后显示主页的过程?      根据域名，进行DNS域名解析； 拿到解析的IP地址，建立TCP连接； 向IP地址，发送HTTP请求； 服务器处理请求； 返回响应结果； 关闭TCP连接； 浏览器解析HTML； 浏览器布局渲染；   Q:DNS解析过程?    Q:HTTP中有个缓存机制，但如何保证缓存是最新的呢？    Q:三次握手过程中可以携带数据吗？    其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据\n为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。\n也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。\nQ:挥手为什么需要四次?    任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。\nQ:非对称密钥加密你了解吗？优缺点？    非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。\n公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。\n非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。\n 优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。  Q:HTTPS采用的加密方式有哪些？是对称还是非对称？    HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。\n确保传输安全过程（其实就是rsa原理）：\n Client给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。 Server确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。 Client确认数字证书有效，然后生成呀一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给Server。 Server使用自己的私钥，获取Client发来的随机数（Premaster secret）。 Client和Server根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。  Q:TCP四大拥塞控制算法总结？（极其重要）    四大算法 拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 慢热启动算法 – Slow Start     所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。 慢启动算法\n 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。 每当收到一个ACK，cwnd大小加一，呈线性上升。 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。 还有一个ssthresh（slow start threshold），是一个上限，当cwnd \u0026gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）  拥塞避免算法 – Congestion Avoidance     如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：\n 收到一个ACK，则cwnd = cwnd + 1 / cwnd 每当过了一个往返延迟时间RTT，cwnd大小加一。 过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。  拥塞发生状态时的算法     一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式，一种是超时重传RTO[Retransmission Timeout]超时，另一个是收到三个重复确认ACK。\n 超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。\n 但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫 做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。\n 超时重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：\n 由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2. cwnd重置为1 进入慢启动过程   最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。\n 所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：\n cwnd大小缩小为当前的一半 ssthresh设置为缩小后的cwnd大小 然后进入快速恢复算法Fast Recovery。  快速恢复算法 – Fast Recovery     TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：\n cwnd = cwnd + 3 MSS，加3 MSS的原因是因为收到3个重复的ACK。 重传DACKs指定的数据包。 如果再收到DACKs，那么cwnd大小增加一。 如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。    如图所示，第五个包发生了丢失，所以导致接收方接收到三次重复ACK，也就是ACK5。所以将ssthresh设置当当时cwnd的一半，也就是6/2 = 3，cwnd设置为3 + 3 = 6。然后重传第五个包。当收到新的ACK时，也就是ACK11，则退出快速恢复阶段，将cwnd重新设置为当前的ssthresh，也就是3，然后进入拥塞避免算法阶段。\nQ:你了解流量控制原理吗？     目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。 TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。  发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。 接收窗：用来标记可以接收的数据大小。   TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。 发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。  Q:TCP 协议如何保证可靠传输？     确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。 数据校验：TCP报文头有校验和，用于校验报文是否损坏。 数据合理分片和排序：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。 流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。 拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。  Q:TCP 利用滑动窗口实现流量控制的机制？    Q:常见的HTTP状态码有哪些？       状态码 类别 含义     1XX Informational（信息性状态码） 接收的请求正在处理   2XX Success（成功状态码） 请求正常处理完毕   3XX Redirection（重定向状态码） 需要进行附加操作以完成请求   4XX Client Error（客户端错误状态码） 服务器无法处理请求   5XX Server Error（服务器错误状态码） 服务器处理请求出    1xx 信息    100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。\n2xx 成功     200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。  3xx 重定向     301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。  4xx 客户端错误     400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found  5xx 服务器错误     500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。  "},{"id":24,"href":"/interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"设计模式","parent":"Interviews","content":""},{"id":25,"href":"/interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"设计模式","parent":"设计模式","content":"  1. 单例（Singleton）  Intent Class Diagram Examples JDK   2. 简单工厂（Simple Factory）  Intent Class Diagram   3. 工厂方法（Factory Method）  Intent Class Diagram JDK   4. 抽象工厂（Abstract Factory）  Intent Class Diagram JDK   5. 生成器（Builder）  Intent Class Diagram JDK   6. 原型模式（Prototype）  Intent Class Diagram JDK     1. 责任链（Chain Of Responsibility）  Intent Class Diagram JDK   2. 命令（Command）  Intent Class Diagram JDK   3. 解释器（Interpreter）  Intent Class Diagram JDK   4. 迭代器（Iterator）  Intent Class Diagram JDK   5. 中介者（Mediator）  Intent Class Diagram JDK   6. 备忘录（Memento）  Intent Class Diagram JDK   7. 观察者（Observer）  Intent JDK   8. 状态（State）  Intent Class Diagram   9. 策略（Strategy）  Intent Class Diagram Implementation JDK   10. 模板方法（Template Method）  Intent Class Diagram JDK   11. 访问者（Visitor）  Intent Class Diagram JDK   12. 空对象（Null）  Intent Class Diagram     1. 适配器（Adapter）  Intent JDK   2. 桥接（Bridge）  Intent Class Diagram JDK   3. 组合（Composite）  Intent Class Diagram JDK   4. 装饰（Decorator）  Intent Class Diagram 设计原则 JDK   5. 外观（Facade）  Intent Class Diagram 设计原则   6. 享元（Flyweight）  Intent Class Diagram JDK   7. 代理（Proxy）  Intent Class Diagram JDK     一、概述    设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。\n拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。\n二、创建型    1. 单例（Singleton）    Intent    确保一个类只有一个实例，并提供该实例的全局访问点。\nClass Diagram    使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。\n私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。\nⅠ 懒汉式-线程不安全    以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。\n这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (uniqueInstance == null) ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 uniqueInstance = new Singleton(); 语句，这将导致实例化多次 uniqueInstance。\npublic class Singleton { private static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } Ⅱ 饿汉式-线程安全    线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。\n但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。\nprivate static Singleton uniqueInstance = new Singleton(); Ⅲ 懒汉式-线程安全    只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。\n但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。\npublic static synchronized Singleton getUniqueInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } Ⅳ 双重校验锁-线程安全    uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。\n双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。\npublic class Singleton { private volatile static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { if (uniqueInstance == null) { synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } 考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 uniqueInstance = new Singleton(); 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。\nif (uniqueInstance == null) { synchronized (Singleton.class) { uniqueInstance = new Singleton(); } } uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：\n 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址  但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1\u0026gt;3\u0026gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1执行了 1 和 3，此时 T2调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。\n使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。\nⅤ 静态内部类实现    当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。\n这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。\npublic class Singleton { private Singleton() { } private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getUniqueInstance() { return SingletonHolder.INSTANCE; } } Ⅵ 枚举实现    public enum Singleton { INSTANCE; private String objName; public String getObjName() { return objName; } public void setObjName(String objName) { this.objName = objName; } public static void main(String[] args) { // 单例测试  Singleton firstSingleton = Singleton.INSTANCE; firstSingleton.setObjName(\u0026#34;firstName\u0026#34;); System.out.println(firstSingleton.getObjName()); Singleton secondSingleton = Singleton.INSTANCE; secondSingleton.setObjName(\u0026#34;secondName\u0026#34;); System.out.println(firstSingleton.getObjName()); System.out.println(secondSingleton.getObjName()); // 反射获取实例测试  try { Singleton[] enumConstants = Singleton.class.getEnumConstants(); for (Singleton enumConstant : enumConstants) { System.out.println(enumConstant.getObjName()); } } catch (Exception e) { e.printStackTrace(); } } } firstName secondName secondName secondName 该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。\n该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。\nExamples     Logger Classes Configuration Classes Accesing resources in shared mode Factories implemented as Singletons  JDK     java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager()  2. 简单工厂（Simple Factory）    Intent    在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。\nClass Diagram    简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。\n这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。\npublic interface Product { } public class ConcreteProduct implements Product { } public class ConcreteProduct1 implements Product { } public class ConcreteProduct2 implements Product { } 以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。\npublic class Client { public static void main(String[] args) { int type = 1; Product product; if (type == 1) { product = new ConcreteProduct1(); } else if (type == 2) { product = new ConcreteProduct2(); } else { product = new ConcreteProduct(); } // do something with the product  } } 以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。\npublic class SimpleFactory { public Product createProduct(int type) { if (type == 1) { return new ConcreteProduct1(); } else if (type == 2) { return new ConcreteProduct2(); } return new ConcreteProduct(); } } public class Client { public static void main(String[] args) { SimpleFactory simpleFactory = new SimpleFactory(); Product product = simpleFactory.createProduct(1); // do something with the product  } } 3. 工厂方法（Factory Method）    Intent    定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。\nClass Diagram    在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。\n下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。\npublic abstract class Factory { abstract public Product factoryMethod(); public void doSomething() { Product product = factoryMethod(); // do something with the product  } } public class ConcreteFactory extends Factory { public Product factoryMethod() { return new ConcreteProduct(); } } public class ConcreteFactory1 extends Factory { public Product factoryMethod() { return new ConcreteProduct1(); } } public class ConcreteFactory2 extends Factory { public Product factoryMethod() { return new ConcreteProduct2(); } } JDK     java.util.Calendar java.util.ResourceBundle java.text.NumberFormat java.nio.charset.Charset java.net.URLStreamHandlerFactory java.util.EnumSet javax.xml.bind.JAXBContext  4. 抽象工厂（Abstract Factory）    Intent    提供一个接口，用于创建 相关的对象家族 。\nClass Diagram    抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。\n抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。\n至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。\n从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。\npublic class AbstractProductA { } public class AbstractProductB { } public class ProductA1 extends AbstractProductA { } public class ProductA2 extends AbstractProductA { } public class ProductB1 extends AbstractProductB { } public class ProductB2 extends AbstractProductB { } public abstract class AbstractFactory { abstract AbstractProductA createProductA(); abstract AbstractProductB createProductB(); } public class ConcreteFactory1 extends AbstractFactory { AbstractProductA createProductA() { return new ProductA1(); } AbstractProductB createProductB() { return new ProductB1(); } } public class ConcreteFactory2 extends AbstractFactory { AbstractProductA createProductA() { return new ProductA2(); } AbstractProductB createProductB() { return new ProductB2(); } } public class Client { public static void main(String[] args) { AbstractFactory abstractFactory = new ConcreteFactory1(); AbstractProductA productA = abstractFactory.createProductA(); AbstractProductB productB = abstractFactory.createProductB(); // do something with productA and productB  } } JDK     javax.xml.parsers.DocumentBuilderFactory javax.xml.transform.TransformerFactory javax.xml.xpath.XPathFactory  5. 生成器（Builder）    Intent    封装一个对象的构造过程，并允许按步骤构造。\nClass Diagram    以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。\npublic class AbstractStringBuilder { protected char[] value; protected int count; public AbstractStringBuilder(int capacity) { count = 0; value = new char[capacity]; } public AbstractStringBuilder append(char c) { ensureCapacityInternal(count + 1); value[count++] = c; return this; } private void ensureCapacityInternal(int minimumCapacity) { // overflow-conscious code  if (minimumCapacity - value.length \u0026gt; 0) expandCapacity(minimumCapacity); } void expandCapacity(int minimumCapacity) { int newCapacity = value.length * 2 + 2; if (newCapacity - minimumCapacity \u0026lt; 0) newCapacity = minimumCapacity; if (newCapacity \u0026lt; 0) { if (minimumCapacity \u0026lt; 0) // overflow  throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE; } value = Arrays.copyOf(value, newCapacity); } } public class StringBuilder extends AbstractStringBuilder { public StringBuilder() { super(16); } @Override public String toString() { // Create a copy, don\u0026#39;t share the array  return new String(value, 0, count); } } public class Client { public static void main(String[] args) { StringBuilder sb = new StringBuilder(); final int count = 26; for (int i = 0; i \u0026lt; count; i++) { sb.append((char) (\u0026#39;a\u0026#39; + i)); } System.out.println(sb.toString()); } } abcdefghijklmnopqrstuvwxyz JDK     java.lang.StringBuilder java.nio.ByteBuffer java.lang.StringBuffer java.lang.Appendable Apache Camel builders  6. 原型模式（Prototype）    Intent    使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。\nClass Diagram    public abstract class Prototype { abstract Prototype myClone(); } public class ConcretePrototype extends Prototype { private String filed; public ConcretePrototype(String filed) { this.filed = filed; } @Override Prototype myClone() { return new ConcretePrototype(filed); } @Override public String toString() { return filed; } } public class Client { public static void main(String[] args) { Prototype prototype = new ConcretePrototype(\u0026#34;abc\u0026#34;); Prototype clone = prototype.myClone(); System.out.println(clone.toString()); } } abc JDK     java.lang.Object#clone()  三、行为型    1. 责任链（Chain Of Responsibility）    Intent    使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。\nClass Diagram     Handler：定义处理请求的接口，并且实现后继链（successor）  public abstract class Handler { protected Handler successor; public Handler(Handler successor) { this.successor = successor; } protected abstract void handleRequest(Request request); } public class ConcreteHandler1 extends Handler { public ConcreteHandler1(Handler successor) { super(successor); } @Override protected void handleRequest(Request request) { if (request.getType() == RequestType.TYPE1) { System.out.println(request.getName() + \u0026#34; is handle by ConcreteHandler1\u0026#34;); return; } if (successor != null) { successor.handleRequest(request); } } } public class ConcreteHandler2 extends Handler { public ConcreteHandler2(Handler successor) { super(successor); } @Override protected void handleRequest(Request request) { if (request.getType() == RequestType.TYPE2) { System.out.println(request.getName() + \u0026#34; is handle by ConcreteHandler2\u0026#34;); return; } if (successor != null) { successor.handleRequest(request); } } } public class Request { private RequestType type; private String name; public Request(RequestType type, String name) { this.type = type; this.name = name; } public RequestType getType() { return type; } public String getName() { return name; } } public enum RequestType { TYPE1, TYPE2 } public class Client { public static void main(String[] args) { Handler handler1 = new ConcreteHandler1(null); Handler handler2 = new ConcreteHandler2(handler1); Request request1 = new Request(RequestType.TYPE1, \u0026#34;request1\u0026#34;); handler2.handleRequest(request1); Request request2 = new Request(RequestType.TYPE2, \u0026#34;request2\u0026#34;); handler2.handleRequest(request2); } } request1 is handle by ConcreteHandler1 request2 is handle by ConcreteHandler2 JDK     java.util.logging.Logger#log() Apache Commons Chain javax.servlet.Filter#doFilter()  2. 命令（Command）    Intent    将命令封装成对象中，具有以下作用：\n 使用命令来参数化其它对象 将命令放入队列中进行排队 将命令的操作记录到日志中 支持可撤销的操作  Class Diagram     Command：命令 Receiver：命令接收者，也就是命令真正的执行者 Invoker：通过它来调用命令 Client：可以设置命令与命令的接收者  设计一个遥控器，可以控制电灯开关。\npublic class LightOnCommand implements Command { Light light; public LightOnCommand(Light light) { this.light = light; } @Override public void execute() { light.on(); } } public class LightOffCommand implements Command { Light light; public LightOffCommand(Light light) { this.light = light; } @Override public void execute() { light.off(); } } public class Light { public void on() { System.out.println(\u0026#34;Light is on!\u0026#34;); } public void off() { System.out.println(\u0026#34;Light is off!\u0026#34;); } } /** * 遥控器 */ public class Invoker { private Command[] onCommands; private Command[] offCommands; private final int slotNum = 7; public Invoker() { this.onCommands = new Command[slotNum]; this.offCommands = new Command[slotNum]; } public void setOnCommand(Command command, int slot) { onCommands[slot] = command; } public void setOffCommand(Command command, int slot) { offCommands[slot] = command; } public void onButtonWasPushed(int slot) { onCommands[slot].execute(); } public void offButtonWasPushed(int slot) { offCommands[slot].execute(); } } public class Client { public static void main(String[] args) { Invoker invoker = new Invoker(); Light light = new Light(); Command lightOnCommand = new LightOnCommand(light); Command lightOffCommand = new LightOffCommand(light); invoker.setOnCommand(lightOnCommand, 0); invoker.setOffCommand(lightOffCommand, 0); invoker.onButtonWasPushed(0); invoker.offButtonWasPushed(0); } } JDK     java.lang.Runnable Netflix Hystrix javax.swing.Action  3. 解释器（Interpreter）    Intent    为语言创建解释器，通常由语言的语法和语法分析来定义。\nClass Diagram     TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。 Context：上下文，包含解释器之外的一些全局信息。  以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。\n例如一颗解析树为 D And (A Or (B C))，文本 \u0026ldquo;D A\u0026rdquo; 满足该解析树定义的规则。\n这里的 Context 指的是 String。\npublic abstract class Expression { public abstract boolean interpret(String str); } public class TerminalExpression extends Expression { private String literal = null; public TerminalExpression(String str) { literal = str; } public boolean interpret(String str) { StringTokenizer st = new StringTokenizer(str); while (st.hasMoreTokens()) { String test = st.nextToken(); if (test.equals(literal)) { return true; } } return false; } } public class AndExpression extends Expression { private Expression expression1 = null; private Expression expression2 = null; public AndExpression(Expression expression1, Expression expression2) { this.expression1 = expression1; this.expression2 = expression2; } public boolean interpret(String str) { return expression1.interpret(str) \u0026amp;\u0026amp; expression2.interpret(str); } } public class OrExpression extends Expression { private Expression expression1 = null; private Expression expression2 = null; public OrExpression(Expression expression1, Expression expression2) { this.expression1 = expression1; this.expression2 = expression2; } public boolean interpret(String str) { return expression1.interpret(str) || expression2.interpret(str); } } public class Client { /** * 构建解析树 */ public static Expression buildInterpreterTree() { // Literal  Expression terminal1 = new TerminalExpression(\u0026#34;A\u0026#34;); Expression terminal2 = new TerminalExpression(\u0026#34;B\u0026#34;); Expression terminal3 = new TerminalExpression(\u0026#34;C\u0026#34;); Expression terminal4 = new TerminalExpression(\u0026#34;D\u0026#34;); // B C  Expression alternation1 = new OrExpression(terminal2, terminal3); // A Or (B C)  Expression alternation2 = new OrExpression(terminal1, alternation1); // D And (A Or (B C))  return new AndExpression(terminal4, alternation2); } public static void main(String[] args) { Expression define = buildInterpreterTree(); String context1 = \u0026#34;D A\u0026#34;; String context2 = \u0026#34;A B\u0026#34;; System.out.println(define.interpret(context1)); System.out.println(define.interpret(context2)); } } true false JDK     java.util.Pattern java.text.Normalizer All subclasses of java.text.Format javax.el.ELResolver  4. 迭代器（Iterator）    Intent    提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。\nClass Diagram     Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator； Iterator 主要定义了 hasNext() 和 next() 方法。 Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。  public interface Aggregate { Iterator createIterator(); } public class ConcreteAggregate implements Aggregate { private Integer[] items; public ConcreteAggregate() { items = new Integer[10]; for (int i = 0; i \u0026lt; items.length; i++) { items[i] = i; } } @Override public Iterator createIterator() { return new ConcreteIterator\u0026lt;Integer\u0026gt;(items); } } public interface Iterator\u0026lt;Item\u0026gt; { Item next(); boolean hasNext(); } public class ConcreteIterator\u0026lt;Item\u0026gt; implements Iterator { private Item[] items; private int position = 0; public ConcreteIterator(Item[] items) { this.items = items; } @Override public Object next() { return items[position++]; } @Override public boolean hasNext() { return position \u0026lt; items.length; } } public class Client { public static void main(String[] args) { Aggregate aggregate = new ConcreteAggregate(); Iterator\u0026lt;Integer\u0026gt; iterator = aggregate.createIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } } JDK     java.util.Iterator java.util.Enumeration  5. 中介者（Mediator）    Intent    集中相关对象之间复杂的沟通和控制方式。\nClass Diagram     Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。 Colleague：同事，相关对象  Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：\npublic class Alarm extends Colleague { @Override public void onEvent(Mediator mediator) { mediator.doEvent(\u0026#34;alarm\u0026#34;); } public void doAlarm() { System.out.println(\u0026#34;doAlarm()\u0026#34;); } } public class CoffeePot extends Colleague { @Override public void onEvent(Mediator mediator) { mediator.doEvent(\u0026#34;coffeePot\u0026#34;); } public void doCoffeePot() { System.out.println(\u0026#34;doCoffeePot()\u0026#34;); } } public class Calender extends Colleague { @Override public void onEvent(Mediator mediator) { mediator.doEvent(\u0026#34;calender\u0026#34;); } public void doCalender() { System.out.println(\u0026#34;doCalender()\u0026#34;); } } public class Sprinkler extends Colleague { @Override public void onEvent(Mediator mediator) { mediator.doEvent(\u0026#34;sprinkler\u0026#34;); } public void doSprinkler() { System.out.println(\u0026#34;doSprinkler()\u0026#34;); } } public abstract class Mediator { public abstract void doEvent(String eventType); } public class ConcreteMediator extends Mediator { private Alarm alarm; private CoffeePot coffeePot; private Calender calender; private Sprinkler sprinkler; public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) { this.alarm = alarm; this.coffeePot = coffeePot; this.calender = calender; this.sprinkler = sprinkler; } @Override public void doEvent(String eventType) { switch (eventType) { case \u0026#34;alarm\u0026#34;: doAlarmEvent(); break; case \u0026#34;coffeePot\u0026#34;: doCoffeePotEvent(); break; case \u0026#34;calender\u0026#34;: doCalenderEvent(); break; default: doSprinklerEvent(); } } public void doAlarmEvent() { alarm.doAlarm(); coffeePot.doCoffeePot(); calender.doCalender(); sprinkler.doSprinkler(); } public void doCoffeePotEvent() { // ...  } public void doCalenderEvent() { // ...  } public void doSprinklerEvent() { // ...  } } public class Client { public static void main(String[] args) { Alarm alarm = new Alarm(); CoffeePot coffeePot = new CoffeePot(); Calender calender = new Calender(); Sprinkler sprinkler = new Sprinkler(); Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler); // 闹钟事件到达，调用中介者就可以操作相关对象  alarm.onEvent(mediator); } } doAlarm() doCoffeePot() doCalender() doSprinkler() JDK     All scheduleXXX() methods of java.util.Timer java.util.concurrent.Executor#execute() submit() and invokeXXX() methods of java.util.concurrent.ExecutorService scheduleXXX() methods of java.util.concurrent.ScheduledExecutorService java.lang.reflect.Method#invoke()  6. 备忘录（Memento）    Intent    在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。\nClass Diagram     Originator：原始对象 Caretaker：负责保存好备忘录 Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。  以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。\n实现参考：Memento Pattern - Calculator Example - Java Sourcecode\n/** * Originator Interface */ public interface Calculator { // Create Memento  PreviousCalculationToCareTaker backupLastCalculation(); // setMemento  void restorePreviousCalculation(PreviousCalculationToCareTaker memento); int getCalculationResult(); void setFirstNumber(int firstNumber); void setSecondNumber(int secondNumber); } /** * Originator Implementation */ public class CalculatorImp implements Calculator { private int firstNumber; private int secondNumber; @Override public PreviousCalculationToCareTaker backupLastCalculation() { // create a memento object used for restoring two numbers  return new PreviousCalculationImp(firstNumber, secondNumber); } @Override public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) { this.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber(); this.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber(); } @Override public int getCalculationResult() { // result is adding two numbers  return firstNumber + secondNumber; } @Override public void setFirstNumber(int firstNumber) { this.firstNumber = firstNumber; } @Override public void setSecondNumber(int secondNumber) { this.secondNumber = secondNumber; } } /** * Memento Interface to Originator * * This interface allows the originator to restore its state */ public interface PreviousCalculationToOriginator { int getFirstNumber(); int getSecondNumber(); } /** * Memento interface to CalculatorOperator (Caretaker) */ public interface PreviousCalculationToCareTaker { // no operations permitted for the caretaker } /** * Memento Object Implementation * \u0026lt;p\u0026gt; * Note that this object implements both interfaces to Originator and CareTaker */ public class PreviousCalculationImp implements PreviousCalculationToCareTaker, PreviousCalculationToOriginator { private int firstNumber; private int secondNumber; public PreviousCalculationImp(int firstNumber, int secondNumber) { this.firstNumber = firstNumber; this.secondNumber = secondNumber; } @Override public int getFirstNumber() { return firstNumber; } @Override public int getSecondNumber() { return secondNumber; } } /** * CareTaker object */ public class Client { public static void main(String[] args) { // program starts  Calculator calculator = new CalculatorImp(); // assume user enters two numbers  calculator.setFirstNumber(10); calculator.setSecondNumber(100); // find result  System.out.println(calculator.getCalculationResult()); // Store result of this calculation in case of error  PreviousCalculationToCareTaker memento = calculator.backupLastCalculation(); // user enters a number  calculator.setFirstNumber(17); // user enters a wrong second number and calculates result  calculator.setSecondNumber(-290); // calculate result  System.out.println(calculator.getCalculationResult()); // user hits CTRL + Z to undo last operation and see last result  calculator.restorePreviousCalculation(memento); // result restored  System.out.println(calculator.getCalculationResult()); } } 110 -273 110 JDK     java.io.Serializable  7. 观察者（Observer）    Intent    定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。\n主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。\n主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。\n观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。\n天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。\nvoid removeObserver(Observer o); void notifyObserver();  }\n ```java public class WeatherData implements Subject { private List\u0026lt;Observer\u0026gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() { observers = new ArrayList\u0026lt;\u0026gt;(); } public void setMeasurements(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; notifyObserver(); } @Override public void registerObserver(Observer o) { observers.add(o); } @Override public void removeObserver(Observer o) { int i = observers.indexOf(o); if (i \u0026gt;= 0) { observers.remove(i); } } @Override public void notifyObserver() { for (Observer o : observers) { o.update(temperature, humidity, pressure); } } } public interface Observer { void update(float temp, float humidity, float pressure); } public class StatisticsDisplay implements Observer { public StatisticsDisplay(Subject weatherData) { weatherData.reisterObserver(this); } @Override public void update(float temp, float humidity, float pressure) { System.out.println(\u0026#34;StatisticsDisplay.update: \u0026#34; + temp + \u0026#34; \u0026#34; + humidity + \u0026#34; \u0026#34; + pressure); } } public class CurrentConditionsDisplay implements Observer { public CurrentConditionsDisplay(Subject weatherData) { weatherData.registerObserver(this); } @Override public void update(float temp, float humidity, float pressure) { System.out.println(\u0026#34;CurrentConditionsDisplay.update: \u0026#34; + temp + \u0026#34; \u0026#34; + humidity + \u0026#34; \u0026#34; + pressure); } } public class WeatherStation { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData); weatherData.setMeasurements(0, 0, 0); weatherData.setMeasurements(1, 1, 1); } } CurrentConditionsDisplay.update: 0.0 0.0 0.0 StatisticsDisplay.update: 0.0 0.0 0.0 CurrentConditionsDisplay.update: 1.0 1.0 1.0 StatisticsDisplay.update: 1.0 1.0 1.0 JDK     java.util.Observer java.util.EventListener javax.servlet.http.HttpSessionBindingListener RxJava  8. 状态（State）    Intent    允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。\nClass Diagram    糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。\n/** * 退回 25 分钱 */ void ejectQuarter(); /** * 转动曲柄 */ void turnCrank(); /** * 发放糖果 */ void dispense();  }\n ```java public class HasQuarterState implements State { private GumballMachine gumballMachine; public HasQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\u0026quot;You can't insert another quarter\u0026quot;); } @Override public void ejectQuarter() { System.out.println(\u0026quot;Quarter returned\u0026quot;); gumballMachine.setState(gumballMachine.getNoQuarterState()); } @Override public void turnCrank() { System.out.println(\u0026quot;You turned...\u0026quot;); gumballMachine.setState(gumballMachine.getSoldState()); } @Override public void dispense() { System.out.println(\u0026quot;No gumball dispensed\u0026quot;); } } public class NoQuarterState implements State { GumballMachine gumballMachine; public NoQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\u0026#34;You insert a quarter\u0026#34;); gumballMachine.setState(gumballMachine.getHasQuarterState()); } @Override public void ejectQuarter() { System.out.println(\u0026#34;You haven\u0026#39;t insert a quarter\u0026#34;); } @Override public void turnCrank() { System.out.println(\u0026#34;You turned, but there\u0026#39;s no quarter\u0026#34;); } @Override public void dispense() { System.out.println(\u0026#34;You need to pay first\u0026#34;); } } public class SoldOutState implements State { GumballMachine gumballMachine; public SoldOutState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\u0026#34;You can\u0026#39;t insert a quarter, the machine is sold out\u0026#34;); } @Override public void ejectQuarter() { System.out.println(\u0026#34;You can\u0026#39;t eject, you haven\u0026#39;t inserted a quarter yet\u0026#34;); } @Override public void turnCrank() { System.out.println(\u0026#34;You turned, but there are no gumballs\u0026#34;); } @Override public void dispense() { System.out.println(\u0026#34;No gumball dispensed\u0026#34;); } } public class SoldState implements State { GumballMachine gumballMachine; public SoldState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\u0026#34;Please wait, we\u0026#39;re already giving you a gumball\u0026#34;); } @Override public void ejectQuarter() { System.out.println(\u0026#34;Sorry, you already turned the crank\u0026#34;); } @Override public void turnCrank() { System.out.println(\u0026#34;Turning twice doesn\u0026#39;t get you another gumball!\u0026#34;); } @Override public void dispense() { gumballMachine.releaseBall(); if (gumballMachine.getCount() \u0026gt; 0) { gumballMachine.setState(gumballMachine.getNoQuarterState()); } else { System.out.println(\u0026#34;Oops, out of gumballs\u0026#34;); gumballMachine.setState(gumballMachine.getSoldOutState()); } } } public class GumballMachine { private State soldOutState; private State noQuarterState; private State hasQuarterState; private State soldState; private State state; private int count = 0; public GumballMachine(int numberGumballs) { count = numberGumballs; soldOutState = new SoldOutState(this); noQuarterState = new NoQuarterState(this); hasQuarterState = new HasQuarterState(this); soldState = new SoldState(this); if (numberGumballs \u0026gt; 0) { state = noQuarterState; } else { state = soldOutState; } } public void insertQuarter() { state.insertQuarter(); } public void ejectQuarter() { state.ejectQuarter(); } public void turnCrank() { state.turnCrank(); state.dispense(); } public void setState(State state) { this.state = state; } public void releaseBall() { System.out.println(\u0026#34;A gumball comes rolling out the slot...\u0026#34;); if (count != 0) { count -= 1; } } public State getSoldOutState() { return soldOutState; } public State getNoQuarterState() { return noQuarterState; } public State getHasQuarterState() { return hasQuarterState; } public State getSoldState() { return soldState; } public int getCount() { return count; } } public class Client { public static void main(String[] args) { GumballMachine gumballMachine = new GumballMachine(5); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.ejectQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.ejectQuarter(); gumballMachine.insertQuarter(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); } } You insert a quarter You turned... A gumball comes rolling out the slot... You insert a quarter Quarter returned You turned, but there\u0026#39;s no quarter You need to pay first You insert a quarter You turned... A gumball comes rolling out the slot... You insert a quarter You turned... A gumball comes rolling out the slot... You haven\u0026#39;t insert a quarter You insert a quarter You can\u0026#39;t insert another quarter You turned... A gumball comes rolling out the slot... You insert a quarter You turned... A gumball comes rolling out the slot... Oops, out of gumballs You can\u0026#39;t insert a quarter, the machine is sold out You turned, but there are no gumballs No gumball dispensed 9. 策略（Strategy）    Intent    定义一系列算法，封装每个算法，并使它们可以互换。\n策略模式可以让算法独立于使用它的客户端。\nClass Diagram     Strategy 接口定义了一个算法族，它们都实现了 behavior() 方法。 Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。  状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。\n状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。\nImplementation    设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。\npublic interface QuackBehavior { void quack(); } public class Quack implements QuackBehavior { @Override public void quack() { System.out.println(\u0026#34;quack!\u0026#34;); } } public class Squeak implements QuackBehavior{ @Override public void quack() { System.out.println(\u0026#34;squeak!\u0026#34;); } } public class Duck { private QuackBehavior quackBehavior; public void performQuack() { if (quackBehavior != null) { quackBehavior.quack(); } } public void setQuackBehavior(QuackBehavior quackBehavior) { this.quackBehavior = quackBehavior; } } public class Client { public static void main(String[] args) { Duck duck = new Duck(); duck.setQuackBehavior(new Squeak()); duck.performQuack(); duck.setQuackBehavior(new Quack()); duck.performQuack(); } } squeak! quack! JDK     java.util.Comparator#compare() javax.servlet.http.HttpServlet javax.servlet.Filter#doFilter()  10. 模板方法（Template Method）    Intent    定义算法框架，并将一些步骤的实现延迟到子类。\n通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。\nClass Diagram    冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。\nfinal void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } abstract void brew(); abstract void addCondiments(); void boilWater() { System.out.println(\u0026quot;boilWater\u0026quot;); } void pourInCup() { System.out.println(\u0026quot;pourInCup\u0026quot;); }  }\n ```java public class Coffee extends CaffeineBeverage { @Override void brew() { System.out.println(\u0026quot;Coffee.brew\u0026quot;); } @Override void addCondiments() { System.out.println(\u0026quot;Coffee.addCondiments\u0026quot;); } } public class Tea extends CaffeineBeverage { @Override void brew() { System.out.println(\u0026#34;Tea.brew\u0026#34;); } @Override void addCondiments() { System.out.println(\u0026#34;Tea.addCondiments\u0026#34;); } } public class Client { public static void main(String[] args) { CaffeineBeverage caffeineBeverage = new Coffee(); caffeineBeverage.prepareRecipe(); System.out.println(\u0026#34;-----------\u0026#34;); caffeineBeverage = new Tea(); caffeineBeverage.prepareRecipe(); } } boilWater Coffee.brew pourInCup Coffee.addCondiments ----------- boilWater Tea.brew pourInCup Tea.addCondiments JDK     java.util.Collections#sort() java.io.InputStream#skip() java.io.InputStream#read() java.util.AbstractList#indexOf()  11. 访问者（Visitor）    Intent    为一个对象结构（比如组合结构）增加新能力。\nClass Diagram     Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作 ConcreteVisitor：具体访问者，存储遍历过程中的累计结果 ObjectStructure：对象结构，可以是组合结构，或者是一个集合。  public interface Element { void accept(Visitor visitor); } class CustomerGroup { private List\u0026lt;Customer\u0026gt; customers = new ArrayList\u0026lt;\u0026gt;(); void accept(Visitor visitor) { for (Customer customer : customers) { customer.accept(visitor); } } void addCustomer(Customer customer) { customers.add(customer); } } public class Customer implements Element { private String name; private List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;(); Customer(String name) { this.name = name; } String getName() { return name; } void addOrder(Order order) { orders.add(order); } public void accept(Visitor visitor) { visitor.visit(this); for (Order order : orders) { order.accept(visitor); } } } public class Order implements Element { private String name; private List\u0026lt;Item\u0026gt; items = new ArrayList(); Order(String name) { this.name = name; } Order(String name, String itemName) { this.name = name; this.addItem(new Item(itemName)); } String getName() { return name; } void addItem(Item item) { items.add(item); } public void accept(Visitor visitor) { visitor.visit(this); for (Item item : items) { item.accept(visitor); } } } public class Item implements Element { private String name; Item(String name) { this.name = name; } String getName() { return name; } public void accept(Visitor visitor) { visitor.visit(this); } } public interface Visitor { void visit(Customer customer); void visit(Order order); void visit(Item item); } public class GeneralReport implements Visitor { private int customersNo; private int ordersNo; private int itemsNo; public void visit(Customer customer) { System.out.println(customer.getName()); customersNo++; } public void visit(Order order) { System.out.println(order.getName()); ordersNo++; } public void visit(Item item) { System.out.println(item.getName()); itemsNo++; } public void displayResults() { System.out.println(\u0026#34;Number of customers: \u0026#34; + customersNo); System.out.println(\u0026#34;Number of orders: \u0026#34; + ordersNo); System.out.println(\u0026#34;Number of items: \u0026#34; + itemsNo); } } public class Client { public static void main(String[] args) { Customer customer1 = new Customer(\u0026#34;customer1\u0026#34;); customer1.addOrder(new Order(\u0026#34;order1\u0026#34;, \u0026#34;item1\u0026#34;)); customer1.addOrder(new Order(\u0026#34;order2\u0026#34;, \u0026#34;item1\u0026#34;)); customer1.addOrder(new Order(\u0026#34;order3\u0026#34;, \u0026#34;item1\u0026#34;)); Order order = new Order(\u0026#34;order_a\u0026#34;); order.addItem(new Item(\u0026#34;item_a1\u0026#34;)); order.addItem(new Item(\u0026#34;item_a2\u0026#34;)); order.addItem(new Item(\u0026#34;item_a3\u0026#34;)); Customer customer2 = new Customer(\u0026#34;customer2\u0026#34;); customer2.addOrder(order); CustomerGroup customers = new CustomerGroup(); customers.addCustomer(customer1); customers.addCustomer(customer2); GeneralReport visitor = new GeneralReport(); customers.accept(visitor); visitor.displayResults(); } } customer1 order1 item1 order2 item1 order3 item1 customer2 order_a item_a1 item_a2 item_a3 Number of customers: 2 Number of orders: 4 Number of items: 6 JDK     javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor  12. 空对象（Null）    Intent    使用什么都不做的空对象来代替 NULL。\n一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。\nClass Diagram    public abstract class AbstractOperation { abstract void request(); } public class RealOperation extends AbstractOperation { @Override void request() { System.out.println(\u0026#34;do something\u0026#34;); } } public class NullOperation extends AbstractOperation{ @Override void request() { // do nothing  } } public class Client { public static void main(String[] args) { AbstractOperation abstractOperation = func(-1); abstractOperation.request(); } public static AbstractOperation func(int para) { if (para \u0026lt; 0) { return new NullOperation(); } return new RealOperation(); } } 四、结构型    1. 适配器（Adapter）    Intent    把一个类接口转换成另一个用户需要的接口。\n鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。\n要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！\npublic interface Duck { void quack(); } public interface Turkey { void gobble(); } public class WildTurkey implements Turkey { @Override public void gobble() { System.out.println(\u0026#34;gobble!\u0026#34;); } } public class TurkeyAdapter implements Duck { Turkey turkey; public TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } @Override public void quack() { turkey.gobble(); } } public class Client { public static void main(String[] args) { Turkey turkey = new WildTurkey(); Duck duck = new TurkeyAdapter(turkey); duck.quack(); } } JDK     java.util.Arrays#asList() java.util.Collections#list() java.util.Collections#enumeration() javax.xml.bind.annotation.adapters.XMLAdapter  2. 桥接（Bridge）    Intent    将抽象与实现分离开来，使它们可以独立变化。\nClass Diagram     Abstraction：定义抽象类的接口 Implementor：定义实现类接口  RemoteControl 表示遥控器，指代 Abstraction。\nTV 表示电视，指代 Implementor。\n桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。\npublic abstract class TV { public abstract void on(); public abstract void off(); public abstract void tuneChannel(); } public class Sony extends TV { @Override public void on() { System.out.println(\u0026#34;Sony.on()\u0026#34;); } @Override public void off() { System.out.println(\u0026#34;Sony.off()\u0026#34;); } @Override public void tuneChannel() { System.out.println(\u0026#34;Sony.tuneChannel()\u0026#34;); } } public class RCA extends TV { @Override public void on() { System.out.println(\u0026#34;RCA.on()\u0026#34;); } @Override public void off() { System.out.println(\u0026#34;RCA.off()\u0026#34;); } @Override public void tuneChannel() { System.out.println(\u0026#34;RCA.tuneChannel()\u0026#34;); } } public abstract class RemoteControl { protected TV tv; public RemoteControl(TV tv) { this.tv = tv; } public abstract void on(); public abstract void off(); public abstract void tuneChannel(); } public class ConcreteRemoteControl1 extends RemoteControl { public ConcreteRemoteControl1(TV tv) { super(tv); } @Override public void on() { System.out.println(\u0026#34;ConcreteRemoteControl1.on()\u0026#34;); tv.on(); } @Override public void off() { System.out.println(\u0026#34;ConcreteRemoteControl1.off()\u0026#34;); tv.off(); } @Override public void tuneChannel() { System.out.println(\u0026#34;ConcreteRemoteControl1.tuneChannel()\u0026#34;); tv.tuneChannel(); } } public class ConcreteRemoteControl2 extends RemoteControl { public ConcreteRemoteControl2(TV tv) { super(tv); } @Override public void on() { System.out.println(\u0026#34;ConcreteRemoteControl2.on()\u0026#34;); tv.on(); } @Override public void off() { System.out.println(\u0026#34;ConcreteRemoteControl2.off()\u0026#34;); tv.off(); } @Override public void tuneChannel() { System.out.println(\u0026#34;ConcreteRemoteControl2.tuneChannel()\u0026#34;); tv.tuneChannel(); } } public class Client { public static void main(String[] args) { RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA()); remoteControl1.on(); remoteControl1.off(); remoteControl1.tuneChannel(); RemoteControl remoteControl2 = new ConcreteRemoteControl2(new Sony()); remoteControl2.on(); remoteControl2.off(); remoteControl2.tuneChannel(); } } JDK     AWT (It provides an abstraction layer which maps onto the native OS the windowing support.) JDBC  3. 组合（Composite）    Intent    将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。\nClass Diagram    组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。\n组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。\npublic abstract class Component { protected String name; public Component(String name) { this.name = name; } public void print() { print(0); } abstract void print(int level); abstract public void add(Component component); abstract public void remove(Component component); } public class Composite extends Component { private List\u0026lt;Component\u0026gt; child; public Composite(String name) { super(name); child = new ArrayList\u0026lt;\u0026gt;(); } @Override void print(int level) { for (int i = 0; i \u0026lt; level; i++) { System.out.print(\u0026#34;--\u0026#34;); } System.out.println(\u0026#34;Composite:\u0026#34; + name); for (Component component : child) { component.print(level + 1); } } @Override public void add(Component component) { child.add(component); } @Override public void remove(Component component) { child.remove(component); } } public class Leaf extends Component { public Leaf(String name) { super(name); } @Override void print(int level) { for (int i = 0; i \u0026lt; level; i++) { System.out.print(\u0026#34;--\u0026#34;); } System.out.println(\u0026#34;left:\u0026#34; + name); } @Override public void add(Component component) { throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点  } @Override public void remove(Component component) { throw new UnsupportedOperationException(); } } public class Client { public static void main(String[] args) { Composite root = new Composite(\u0026#34;root\u0026#34;); Component node1 = new Leaf(\u0026#34;1\u0026#34;); Component node2 = new Composite(\u0026#34;2\u0026#34;); Component node3 = new Leaf(\u0026#34;3\u0026#34;); root.add(node1); root.add(node2); root.add(node3); Component node21 = new Leaf(\u0026#34;21\u0026#34;); Component node22 = new Composite(\u0026#34;22\u0026#34;); node2.add(node21); node2.add(node22); Component node221 = new Leaf(\u0026#34;221\u0026#34;); node22.add(node221); root.print(); } } Composite:root --left:1 --Composite:2 ----left:21 ----Composite:22 ------left:221 --left:3 JDK     javax.swing.JComponent#add(Component) java.awt.Container#add(Component) java.util.Map#putAll(Map) java.util.List#addAll(Collection) java.util.Set#addAll(Collection)  4. 装饰（Decorator）    Intent    为对象动态添加功能。\nClass Diagram    装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。\n设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。\n下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。\npublic class DarkRoast implements Beverage { @Override public double cost() { return 1; } } public class HouseBlend implements Beverage { @Override public double cost() { return 1; } } public abstract class CondimentDecorator implements Beverage { protected Beverage beverage; } public class Milk extends CondimentDecorator { public Milk(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return 1 + beverage.cost(); } } public class Mocha extends CondimentDecorator { public Mocha(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return 1 + beverage.cost(); } } public class Client { public static void main(String[] args) { Beverage beverage = new HouseBlend(); beverage = new Mocha(beverage); beverage = new Milk(beverage); System.out.println(beverage.cost()); } } 3.0 设计原则    类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。\n不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。\nJDK     java.io.BufferedInputStream(InputStream) java.io.DataInputStream(InputStream) java.io.BufferedOutputStream(OutputStream) java.util.zip.ZipOutputStream(OutputStream) java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap  5. 外观（Facade）    Intent    提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。\nClass Diagram    观看电影需要操作很多电器，使用外观模式实现一键看电影功能。\npublic class SubSystem { public void turnOnTV() { System.out.println(\u0026#34;turnOnTV()\u0026#34;); } public void setCD(String cd) { System.out.println(\u0026#34;setCD( \u0026#34; + cd + \u0026#34; )\u0026#34;); } public void startWatching(){ System.out.println(\u0026#34;startWatching()\u0026#34;); } } public class Facade { private SubSystem subSystem = new SubSystem(); public void watchMovie() { subSystem.turnOnTV(); subSystem.setCD(\u0026#34;a movie\u0026#34;); subSystem.startWatching(); } } public class Client { public static void main(String[] args) { Facade facade = new Facade(); facade.watchMovie(); } } 设计原则    最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。\n6. 享元（Flyweight）    Intent    利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。\nClass Diagram     Flyweight：享元对象 IntrinsicState：内部状态，享元对象共享内部状态 ExtrinsicState：外部状态，每个享元对象的外部状态不同  public interface Flyweight { void doOperation(String extrinsicState); } public class ConcreteFlyweight implements Flyweight { private String intrinsicState; public ConcreteFlyweight(String intrinsicState) { this.intrinsicState = intrinsicState; } @Override public void doOperation(String extrinsicState) { System.out.println(\u0026#34;Object address: \u0026#34; + System.identityHashCode(this)); System.out.println(\u0026#34;IntrinsicState: \u0026#34; + intrinsicState); System.out.println(\u0026#34;ExtrinsicState: \u0026#34; + extrinsicState); } } public class FlyweightFactory { private HashMap\u0026lt;String, Flyweight\u0026gt; flyweights = new HashMap\u0026lt;\u0026gt;(); Flyweight getFlyweight(String intrinsicState) { if (!flyweights.containsKey(intrinsicState)) { Flyweight flyweight = new ConcreteFlyweight(intrinsicState); flyweights.put(intrinsicState, flyweight); } return flyweights.get(intrinsicState); } } public class Client { public static void main(String[] args) { FlyweightFactory factory = new FlyweightFactory(); Flyweight flyweight1 = factory.getFlyweight(\u0026#34;aa\u0026#34;); Flyweight flyweight2 = factory.getFlyweight(\u0026#34;aa\u0026#34;); flyweight1.doOperation(\u0026#34;x\u0026#34;); flyweight2.doOperation(\u0026#34;y\u0026#34;); } } Object address: 1163157884 IntrinsicState: aa ExtrinsicState: x Object address: 1163157884 IntrinsicState: aa ExtrinsicState: y JDK    Java 利用缓存来加速大量小对象的访问时间。\n java.lang.Integer#valueOf(int) java.lang.Boolean#valueOf(boolean) java.lang.Byte#valueOf(byte) java.lang.Character#valueOf(char)  7. 代理（Proxy）    Intent    控制对其它对象的访问。\nClass Diagram    代理有以下四类：\n 远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。 虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。 保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。 智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。  以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。\npublic interface Image { void showImage(); } public class HighResolutionImage implements Image { private URL imageURL; private long startTime; private int height; private int width; public int getHeight() { return height; } public int getWidth() { return width; } public HighResolutionImage(URL imageURL) { this.imageURL = imageURL; this.startTime = System.currentTimeMillis(); this.width = 600; this.height = 600; } public boolean isLoad() { // 模拟图片加载，延迟 3s 加载完成  long endTime = System.currentTimeMillis(); return endTime - startTime \u0026gt; 3000; } @Override public void showImage() { System.out.println(\u0026#34;Real Image: \u0026#34; + imageURL); } } public class ImageProxy implements Image { private HighResolutionImage highResolutionImage; public ImageProxy(HighResolutionImage highResolutionImage) { this.highResolutionImage = highResolutionImage; } @Override public void showImage() { while (!highResolutionImage.isLoad()) { try { System.out.println(\u0026#34;Temp Image: \u0026#34; + highResolutionImage.getWidth() + \u0026#34; \u0026#34; + highResolutionImage.getHeight()); Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } highResolutionImage.showImage(); } } public class ImageViewer { public static void main(String[] args) throws Exception { String image = \u0026#34;http://image.jpg\u0026#34;; URL url = new URL(image); HighResolutionImage highResolutionImage = new HighResolutionImage(url); ImageProxy imageProxy = new ImageProxy(highResolutionImage); imageProxy.showImage(); } } JDK     java.lang.reflect.Proxy RMI  参考资料     弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007. Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007. Bloch J. Effective java[M]. Addison-Wesley Professional, 2017. Design Patterns Design patterns implemented in Java The breakdown of design patterns in JDK  "},{"id":26,"href":"/interview/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/","title":"链表","parent":"算法","content":"  删除给定值的节点  Q:删除链表中等于给定值 val 的所有节点   反转链表  Q:反转一个单链表   删除倒数第k个节点  Q:给定一链表,删除倒数第K个节点     删除给定值的节点    Q:删除链表中等于给定值 val 的所有节点    输入:1-\u0026gt;2-\u0026gt;6-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6,val=6 输出:1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5   关键点\n 创建虚拟头结点,用来删除第一个元素   ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点  dummyHead-\u0026gt;next = head; // 将虚拟头结点指向head，这样方面后面做删除操作  ListNode* cur = dummyHead; while (cur-\u0026gt;next != NULL) { if(cur-\u0026gt;next-\u0026gt;val == val) { ListNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; } else { cur = cur-\u0026gt;next; } } return dummyHead-\u0026gt;next; } 反转链表    Q:反转一个单链表    输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL   关键点\n 双指针   ListNode* reverseList(ListNode* head) { ListNode* temp; // 保存cur的下一个节点  ListNode* cur = head; ListNode* pre = NULL; while(cur) { temp = cur-\u0026gt;next; // 保存一下 cur的下一个节点，因为接下来要改变cur-\u0026gt;next  cur-\u0026gt;next = pre; // 翻转操作  // 更新pre 和 cur指针  pre = cur; cur = temp; } return pre; } 删除倒数第k个节点    Q:给定一链表,删除倒数第K个节点    输入:1-\u0026gt;3-\u0026gt;5-\u0026gt;7-\u0026gt;6 K=3 输出:1-\u0026gt;3-\u0026gt;7-\u0026gt;6   关键点\n 双指针   ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(0); dummyHead-\u0026gt;next = head; ListNode* slow = dummyHead; ListNode* fast = dummyHead; while(n-- \u0026amp;\u0026amp; fast != NULL) { fast = fast-\u0026gt;next; } fast = fast-\u0026gt;next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点  while (fast != NULL) { fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } slow-\u0026gt;next = slow-\u0026gt;next-\u0026gt;next; return dummyHead-\u0026gt;next; } "},{"id":27,"href":"/interview/java/%E9%9B%86%E5%90%88/","title":"集合","parent":"Java","content":"  HashMap:  Q:准备用HashMap存1w条数据，构造时传10000还会触发扩容吗？ Q:扰动函数是什么?有什么用? Q:HashMap中的初始化容量,如果传入17,最初的大小是多少? Q:HashMap的数据存储? Q:HashMap.put数据是怎么样的?需要注意些什么? Q:HashMap中红黑树是怎么实现新增的? Q:链表转红黑树定义的长度为什么是8？ Q:HashMap为什么每次都是以 2的幂次方扩容？ Q:HashMap是如何进行resize操作的? Q:HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？   ArrayList:  Q:ArrayList解析?   CopyOnWriteArrayList:  Q:CopyOnWriteArrayList是如何保证线程安全的? Q:CopyOnWriteArraylist中已经有互斥锁了,为什么还需要copy数据?   ConcurrentHashMap:  Q:ConcurrentHashMap是如何保证线程安全的?   LinkedHashMap:  Q:LinkedHashMap是如何实现LRU的?   队列  Q:队列的存取 API 都有什么区别？比如 put take 和 offer poll? Q:ArrayBlockingQueue有什么特点? Q:哪些队列有阻塞功能?是如何实现的? Q:假设 SynchronousQueue 底层使用的是堆栈，线程 1 执行 take 操作阻塞住了，然后有线程 2 执行 put 操作，问此时线程 2 是如何把 put 的数据传递给 take 的？   Q:描述下ArrayMap? Q:TreeMap 的内部是怎么排序的? Q:Treemap底层是怎么根据 key 排序的? Q:各集合中的数据存储对象 Q:什么是Fail-Fast机制? Q:Collection中有什么经常使用到的函数、方法?   HashMap:      Q:准备用HashMap存1w条数据，构造时传10000还会触发扩容吗？    不会,经过trimToSize的话,会申请2的n次幂大小空间,乘以0.75系数后也足够10000条数据使用\n  Q:扰动函数是什么?有什么用?    java8中的扰动函数:(h = key.hashCode()) ^ (h \u0026raquo;\u0026gt; 16),作用是为了增加hash的随机性\n  Q:HashMap中的初始化容量,如果传入17,最初的大小是多少?    会找最近的2的幂次方,17的话,最初大小为2的5次方=32\n  Q:HashMap的数据存储?    数组+链表+红黑树,当链表长度大于等于 8 并且数组长度大于 64,就会转为红黑树\n  Q:HashMap.put数据是怎么样的?需要注意些什么?     1、根据 key 通过该公式 (h = key.hashCode()) ^ (h \u0026raquo;\u0026gt; 16) 计算 hash 值 2、判断 HashMap table 数组是否已经初始化，如果没有初始化，那么就按照默认 16 的大小进行初始化，扩容阀值也将按照 size * 0.75 来定义 3、通过该公式 (n - 1) \u0026amp; hash 拿到存入 table 的 index 索引，判断当前索引下是否有值，如果没有值就进行直接赋值 tab[index] , 如果有值，那么就会发生 hash 碰撞 💥 ，也就是俗称 hash冲突 , 在 JDK中的解决是的办法有 2 个，其一是链表，其二是 红黑树。 4、当发送 hash 冲突 首先判断数组中已存入的 key 是否与当前存入的 key 相同，并且内存地址也一样，那么就直接默认直接覆盖 values 5、如果 key 不相等，那么先拿到 tab[index] 中的 Node是否是红黑树，如果是红黑树，那么就加入红黑树的节点；如果 Node 节点不是红黑树，那么就直接放入 node 的 next 下，形成单链表结构。 6、如果链表结构的长度 \u0026gt;= 8 就转为红黑树的结构。 7、最后检查扩容机制    Q:HashMap中红黑树是怎么实现新增的?     1、首先判断新增的节点在红黑树上是不是已经存在，判断手段有如下两种 1.1、如果节点没有实现 Comparable 接口，使用 equals 进行判断； 1.2、如果节点自己实现了 Comparable 接口，使用 compareTo 进行判断。 2、新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大； 3、自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点； 4、把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系； 5、进行着色和旋转，结束。    Q:链表转红黑树定义的长度为什么是8？    链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候，使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值\n  Q:HashMap为什么每次都是以 2的幂次方扩容？     来是比取余操作更加有效率 只有当数组长度为2的幂次方时，h\u0026amp;(length-1)才等价于h%length 解决了“哈希值与数组大小范围不匹配”的问题    Q:HashMap是如何进行resize操作的?      Q:HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？      hashCode()方法返回的是int整数类型，其范围为-(2^31)~(2^31-1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置\nArrayList:      Q:ArrayList解析?    public ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { this.elementData = new Object[initialCapacity];//transient  } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } public void add(int index, E element) { if (index \u0026gt; size || index \u0026lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); ensureCapacityInternal(size + 1); // Increments modCount!!,执行扩容操作  System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } private void grow(int minCapacity) { // overflow-conscious code  int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1);//扩容为原来的1.5倍  if (newCapacity - minCapacity \u0026lt; 0)//minCapacity = currSize+1  newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0)//MAX_ARRAY_SIZE=Integer.MAX_VALUE - 8  newCapacity = hugeCapacity(minCapacity);//minCapacity\u0026lt;0 抛出oom  // minCapacity is usually close to size, so this is a win:  elementData = Arrays.copyOf(elementData, newCapacity); } public E remove(int index) { if (index \u0026gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work  return oldValue; } public boolean remove(Object o) { if (o == null) { for (int index = 0; index \u0026lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index \u0026lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } // 1.ArrayList 底层实现是基于数组的，因此对指定下标的查找和修改比较快，但是删除和插入操作比较慢。 // 2.构造 ArrayList 时尽量指定容量，减少扩容时带来的数组复制操作，如果不知道大小可以赋值为默认容量 10。 // 3.每次添加元素之前会检查是否需要扩容，每次扩容都是增加原有容量的一半。 // 4.每次对下标的操作都会进行安全性检查，如果出现数组越界就立即抛出异常。 // 5.ArrayList 的所有方法都没有进行同步，因此它不是线程安全的。 // 6.扩容机制,扩容到1.5-\u0026gt;扩容到指定大小-\u0026gt;扩容到最大Int // 7.删除就是找到元素变更的索引,然后通过System.arraycopy进行数组移动   CopyOnWriteArrayList:      Q:CopyOnWriteArrayList是如何保证线程安全的?     线程安全的，多线程环境下可以直接使用，无需加锁； 通过锁 + 数组拷贝 + volatile 关键字保证了线程安全； 每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去  public boolean add(E e) { final ReentrantLock lock = this.lock; //加锁  lock.lock(); try { // 得到所有的原数组  Object[] elements = getArray(); int len = elements.length; //拷贝到新数组里面，新数组的长度是 + 1 的  Object[] newElements = Arrays.copyOf(elements, len + 1); //在新数组中进行赋值，新元素直接放在数组的尾部  newElements[len] = e; //替换原来的数组  setArray(newElements); return true; } finally { lock.unlock(); } } // 1、通过可重入互斥锁 ReentrantLock对 add(E) 加锁 // 2、通过 getArray() 方法得到已经存在的数组 // 3、实例化一个长度为当前 size + 1 的数组，然后将 getArray 的数组放入新数组中 // 4、最后将添加的数据存入新数组的最后索引中 // 5、基于当前类中的 setArray(newElements); 来替换缓存中的数组数据，因为它在类中中被 volatile 修饰了，所以只要内存地址一变，那么就会立马通知，其它 CPU 的缓存让它得到更新。 // 6、释放可重入互斥锁    Q:CopyOnWriteArraylist中已经有互斥锁了,为什么还需要copy数据?    是为了触发地址改变,是voliate关键字起效,将改变通知到其他线程\n  ConcurrentHashMap:      Q:ConcurrentHashMap是如何保证线程安全的?     put操作:   数组初始化时通过自旋 + CAS + 双重 check 等手段保证了数组初始化时的线程安全 新增槽点时的线程安全  通过自旋死循环保证一定可以新增成功。 当前槽点为空时，通过 CAS 新增。 当前槽点有值，通过sychronized锁住当前槽点。 红黑树旋转时，通过CAS锁住红黑树的根节点   扩容时的线程安全  拷贝槽点时，会把原数组的槽点锁住 拷贝成功之后，会把原数组的槽点设置成转移节点，这样如果有数据需要 put 到该节点时，发现该槽点是转移节点，会一直等待，直到扩容成功之后，才能继续 put 从尾到头进行拷贝，拷贝成功就把原数组的槽点设置成转移节点      LinkedHashMap:      Q:LinkedHashMap是如何实现LRU的?    LinkedHashMap是一个单向的链表结构  put操作 默认会按照插入顺序,插入到队尾,会通过afterNodeInsertion删除头部元素 get操作 会将最后访问的元素移动到队尾    队列      Q:队列的存取 API 都有什么区别？比如 put take 和 offer poll?     遇到队列满或空的时候，抛异常，如 add、remove、element； 遇到队列满或空的时候，返回特殊值，如 offer、poll、peek。    Q:ArrayBlockingQueue有什么特点?     有界的阻塞数组，容量一旦创建，后续大小无法修改； 元素是有顺序的，按照先入先出进行排序，从队尾插入数据数据，从队头拿数据； 队列满时，往队列中 put 数据会被阻塞，队列空时，往队列中拿数据也会被阻塞。    Q:哪些队列有阻塞功能?是如何实现的?     LinkedBlockingQueue 链表阻塞队列和 ArrayBlockingQueue 数组阻塞队列是一类，前者容量是 Integer 的最大值，后者数组大小固定，两个阻塞队列都可以指定容量大小，当队列满时，如果有线程 put 数据，线程会阻塞住，直到有其他线程进行消费数据后，才会唤醒阻塞线程继续 put，当队列空时，如果有线程 take 数据，线程会阻塞到队列不空时，继续 take。 SynchronousQueue 同步队列，当线程 put 时，必须有对应线程把数据消费掉，put 线程才能返回，当线程 take 时，需要有对应线程进行 put 数据时，take 才能返回，反之则阻塞，举个例子，线程 A put 数据 A1 到队列中了，此时并没有任何的消费者，线程 A 就无法返回，会阻塞住，直到有线程消费掉数据 A1 时，线程 A 才能返回。    Q:假设 SynchronousQueue 底层使用的是堆栈，线程 1 执行 take 操作阻塞住了，然后有线程 2 执行 put 操作，问此时线程 2 是如何把 put 的数据传递给 take 的？    首先线程 1 被阻塞住，此时堆栈头就是线程 1 了，此时线程 2 执行 put 操作，会把 put 的数据赋值给堆栈头的 match 属性，并唤醒线程 1，线程 1 被唤醒后，拿到堆栈头中的 match 属性，就能够拿到 put 的数据了。\n严格上说并不是 put 操作直接把数据传递给了 take，而是 put 操作改变了堆栈头的数据，从而 take 可以从堆栈头上直接拿到数据，堆栈头是 take 和 put 操作之间的沟通媒介\n  Q:描述下ArrayMap?    ArrayMap 底层通过两个数组来建立映射关系，其中 int[] mHashes 按大小顺序保存 Key 对象 hashCode 值，Object[] mArray 按 mHashes 的顺序用相邻位置保存 Key 对象和 Value 对象。mArray 长度 是 mHashes 长度的 2 倍\nQ:TreeMap 的内部是怎么排序的?    它的底层还是红黑树结构，跟 HashMap 的红黑树是一样的。然后 TreeMap 是利用了红黑树左大右小的性质，根据 key 来进行排序的\nQ:Treemap底层是怎么根据 key 排序的?     判断红黑树的节点是否为空，为空的话，新增的节点直接作为根节点 根据红黑树左小右大的特性，进行判断，找到应该新增节点的父节点 在父节点的左边或右边插入新增节点 着色旋转，达到平衡，结束。  Q:各集合中的数据存储对象    //HashMap.HashMapEntry final K key; V value; HashMapEntry\u0026lt;K,V\u0026gt; next; int hash; //ConcurrentHashMap.Node final K key; volatile V val; volatile Node\u0026lt;K,V\u0026gt; next; final int hash; Q:什么是Fail-Fast机制?    当每次进行类似add、remove操作时,都会对操作数modCount执行+1操作,在使用迭代器等进行迭代操作时,会判断modCount与期望modCount的值,如果不相等就抛出ConcurrentModificationException\nQ:Collection中有什么经常使用到的函数、方法?    Collection.sort():排序算法,Comparator Collection.binarySearch():二分查找 Collections.shuffle():洗牌算法,随机数 Collections.rotate():旋转算法,将list中的元素形成一个环,顺时针旋转n位\n"},{"id":28,"href":"/interview/_includes/","title":"Includes","parent":"Interviews","content":""},{"id":29,"href":"/interview/_includes/include-page/","title":"Include Page","parent":"Includes","content":"Example page include\nExample Shortcode\nShortcode used in an include page.     Head 1 Head 2 Head 3     1 2 3    "},{"id":30,"href":"/interview/android/%E5%8A%A8%E7%94%BB/","title":"动画","parent":"Android","content":"Q:View动画为何不能真正改变View的位置？而属性动画为何可以？属性动画是如何改变View的属性？    Q:属性动画插值器和估值器的作用？插值器和估值器分别是如何更改动画的？    "},{"id":31,"href":"/categories/","title":"Categories","parent":"十万个为什么","content":""},{"id":32,"href":"/tags/","title":"Tags","parent":"十万个为什么","content":""}]