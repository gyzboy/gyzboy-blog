<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 十万个为什么</title>
    <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on 十万个为什么</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 13 Apr 2021 16:12:16 +0800</lastBuildDate><atom:link href="https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数组</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</guid>
      <description>有序数组索引  Q:从排序数组中找到目标值并返回其索引   原地删除元素  Q:给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度?   最小子串  Q:给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0     有序数组索引    Q:从排序数组中找到目标值并返回其索引     输入: [1,3,5,6], 5 输出: 2   关键点:
 有序数组 边界处理   int searchInsert1(int[] nums, int target) { int n = nums.length(); int left = 0; int right = n - 1; // 定义target在左闭右闭的区间里，[left, right]  while (left &amp;lt;= right) { // 当left==right，区间[left, right]依然有效  int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2  if (nums[middle] &amp;gt; target) { right = middle - 1; // target 在左区间，所以[left, middle - 1]  } else if (nums[middle] &amp;lt; target) { left = middle + 1; // target 在右区间，所以[middle + 1, right]  } else { // nums[middle] == target  return middle; } } // 分别处理如下四种情况  // 目标值在数组所有元素之前 [0, -1]  // 目标值等于数组中某一个元素 return middle;  // 目标值插入数组中的位置 [left, right]，return right + 1  // 目标值在数组所有元素之后的情况 [left, right]， return right + 1  return right + 1; int searchInsert2(int[] nums, int target) { int n = nums.</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</guid>
      <description>删除给定值的节点  Q:删除链表中等于给定值 val 的所有节点   反转链表  Q:反转一个单链表   删除倒数第k个节点  Q:给定一链表,删除倒数第K个节点     删除给定值的节点    Q:删除链表中等于给定值 val 的所有节点    输入:1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6,val=6 输出:1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5   关键点
 创建虚拟头结点,用来删除第一个元素   ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点  dummyHead-&amp;gt;next = head; // 将虚拟头结点指向head，这样方面后面做删除操作  ListNode* cur = dummyHead; while (cur-&amp;gt;next != NULL) { if(cur-&amp;gt;next-&amp;gt;val == val) { ListNode* tmp = cur-&amp;gt;next; cur-&amp;gt;next = cur-&amp;gt;next-&amp;gt;next; delete tmp; } else { cur = cur-&amp;gt;next; } } return dummyHead-&amp;gt;next; } 反转链表    Q:反转一个单链表    输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL   关键点</description>
    </item>
    
  </channel>
</rss>
